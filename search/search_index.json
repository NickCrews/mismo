{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mismo","text":"<p>Mismo is a python framework for Record Linkage, built on top of Ibis. It allows you to deduplicate and link records from tables that don't have a unique identifier.</p> <ul> <li>Take a database of campaign contributions and determine which   were made by the same person</li> <li>Determining which product listings actually refer to the same item.</li> <li>Linking businesses across different datasets.</li> </ul>"},{"location":"#example","title":"Example","text":"<p>See the example notebooks.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>Examples<ul> <li>Patent Deduplication</li> </ul> </li> <li>Concepts<ul> <li>Goals and Alternatives</li> <li>Fellegi-Sunter Model</li> <li>Versioning Policy</li> </ul> </li> <li>Reference<ul> <li>Core API</li> <li>By Task<ul> <li>EDA</li> <li>Joining</li> <li>Comparing<ul> <li>Fellegi-Sunter</li> </ul> </li> <li>Clustering</li> <li>Datasets</li> <li>Play Data</li> </ul> </li> <li>By Data Type<ul> <li>Text Utils</li> <li>Array Utils</li> <li>Set Utils</li> <li>Vector Utils</li> </ul> </li> <li>By Domain<ul> <li>Geospatial</li> <li>Human Names</li> <li>Emails</li> <li>Phones</li> </ul> </li> <li>Exceptions</li> </ul> </li> <li>Contribute</li> </ul>"},{"location":"contributing/","title":"How to contribute","text":""},{"location":"contributing/#dependencies","title":"Dependencies","text":"<p>We use <code>uv</code> as our package and dependency management tool. Install that  per uv's instructions.  As of this writing, this is done by running: <pre><code>curl -LsSf https://astral.sh/uv/0.4.18/install.sh | sh\n</code></pre></p> <p>We use <code>just</code> and a  justfile  to automate many of the common development tasks. The rest of this guide will assume you have just installed. If you don't want to use <code>just</code>, you can manually run recipes from the  justfile.</p>"},{"location":"contributing/#setup-dev-environemnt","title":"Setup dev environemnt","text":"<p>Once <code>uv</code> (and optionally <code>just</code>) are installed, run <code>just install</code>. This will create a virtual environment in <code>.venv/</code> and install all the locked dependencies from <code>uv.lock</code>.</p> <p>Now you can run common tasks such as - <code>just test</code> - <code>just fmt</code> - <code>just lint</code></p>"},{"location":"concepts/fs/","title":"Fellegi-Sunter Model","text":"<p>The Fellegi-Sunter model is a linear model commonly used for record linkage. It uses bayesian statistics to assign odds to different levels of agreement for different dimensions. For example, \"if two names are exactly the same, that makes the odds of a match 7.6 times more likely\". The dimension is \"name\" and the level of agreement is \"exactly the same\". You then combine the multiple dimensions (\"name\", \"location\", \"price\", etc) together to get a final odds for a record pair. You can train the weights using labeled data, or from unlabeled data with an EM (Expectation Maximization) Algorithm.</p> <p>This is the model used by Splink, and I am trying to copy that over to Mismo.</p>"},{"location":"concepts/fs/#glossary","title":"Glossary","text":""},{"location":"concepts/fs/#odds","title":"Odds","text":"<p>Odds of 4 mean that an event is four times more likely to happen than not happen. I other words, it happens four out of five times. Odds of 1/4 or .25 is the opposite: it is 4 times more likely to not happen than happen. Odds of 1 means that happening and not happening are equally likely.</p> <p>Odds can be combined via multiplication, assuming the events are independent. For example, if you draw two records at random, say the odds of the first name matching are 1/10_000, and the gender matching is 1/2. Therefore, the combined odds that the first name matches AND the gender matches is <code>1/10_000 * 1/2 = 1/20_000</code>.</p> <p>In Splink and other contexts, they use the term \"Bayes Factor\" to mean the same thing as \"odds\". I use \"odds\" because it is shorter, and I think more intuitive to people who don't know bayesian statistics. It's not that complicated and \"odds\" is precise enough.</p>"},{"location":"concepts/fs/#log-odds","title":"Log Odds","text":"<p>The logarithm (base 10) of <code>Odds</code>. This is useful because it allows match weights to be added together rather than being multiplied (as Odds are). This is useful so we can visualize comparisons between records using a waterfall chart.</p> <p>For example, with the odds of 100 and 1/10, if we combined these two, we would get a total odds of <code>100 * (1/10) = 10</code>. If we instead combined them using log odds: The individual log odds would be 2 and -1, and the combined match weight would be <code>2 + (-1) = 1</code>, which corresponds to a <code>Log Odds</code> of 1, as expected.</p> <p>Here is a table to help you get a sense between these two:</p> Odds Log Odds 0 -inf ... ... .01 -2 .1 -1 1 0 10 1 100 2 ... ... inf inf <p>In Splink and other contexts, they use the term \"Match Weight\" to mean \"Log Odds\". They also use log base 2, but I chose to use log base 10 because I think it is easier to convert back and forth.</p>"},{"location":"concepts/fs/#m-probabilities","title":"M probabilities","text":"<p>Amongst record comparisons which are true matches, what proportion have a match on first name, and what proportion mismatch on first name?</p> <p>This is a measure of how often mispellings, nicknames or aliases occur in the first name field.</p>"},{"location":"concepts/fs/#u-probabilities","title":"U probabilities","text":"<p>Amongst record comparisons which are true non-matches, what proportion have a match on first name, and what proportion mismatch on first name?</p> <p>This is a measure of how likely 'collisions' are likely to occur. For instance, it would be common for two different people to have the same gender, but less likely for two different people to have the same date of birth.</p>"},{"location":"concepts/goals_and_alternatives/","title":"Goals and Alternatives","text":"<ul> <li>Small, composable components that are easy to understand and extend.</li> <li>Use standard data structures like Ibis tables whenever possible.   Expose these as transparent dataclasses that the user is free to   reach into directly. The opposite of this would be a heavily   object-oriented API where all the internal state is intentionally   hidden from the user: I find this sort of API leaves the user   with no escape hatch to do the thing they need to do.   See this excellent talk by Casey Muratori   for more on this.</li> <li>Use pure functions and immutable data structures whenever possible.</li> <li>Have some built-in algorithms such as a splink-inspired Fellegi-Sunter   model so you can get going out of the box, but also leave the door open   for others to plug in their own blocking, comparing, and clustering   algorithms. If we design the interfaces between all these stages carefully,   then they should all inter-operate and individual components can be swapped   out for better/custom implementations. Ideally this could position mismo   as the de-facto experimental platform, similar to how huggingface and pytorch   are the standard platforms for machine learning.   platform for researchers. </li> <li>3rd party IS 1st party: It should be as easy for 3rd party authors to extend   mismo as it is to implement those features directly in the core.   APIs should also be exposed</li> <li>Wrap the core logic in helper classes to make it easy to get started, but   have these be shortcuts instead of dead ends.</li> <li>Reproducible results using <code>random_state</code> similar to sklearn. No peer of Mismo   seems to do this.</li> <li>Separation between specification and data. eg you define linkage model abstractly,   without needing the actual tables of data. Then, at a later step, you actually   apply the model to the data. This makes it so you can re-apply the same model   to different datasets, eg if you have a linkage job you need to run nightly.   This also makes it easier to save and load model specifications,    share them with others, and adjust them for doing A/B testing.</li> </ul> <p>This is similar to how in ibis, you define abstract expressions that aren't   bound to any concrete data, and then only at execution time do you   need to have the backend and data available. - Python-first approach. Instead of configuring using JSON, the majority of   the implementation logic should be in python. This prevents dead ends and makes   things much more extendable. I found with splink that the JSON representation   of a model was often inadequate: the data loading and cleaning steps are just   as important to have a reproducible workflow, but those are only defined in   python code and are excluded from the JSON. - Be useful for resolving datasets with disparate schemas: Instead of determining   \"do these records from different datasets refer to the same person?\", you should   also be able to determine \"which politician does this campaign contribution go to?\".   In the first case, both records are \"people\", so they probably have similar schemas.   In the second case, one record is a person, and the other is a contribution, so   they likely have different schemas. The leading libraries of <code>splink</code> and <code>dedupe</code>   do not account for this.</p>"},{"location":"concepts/goals_and_alternatives/#what-mismo-is-not-good-for","title":"What Mismo is NOT good for","text":"<ul> <li>Mismo is targeted for programmers moderately proficient in python.   It does not have GUI or any sort of interface that makes it suitable   for non-techinical users.</li> <li>Having a single JSON file representation of the model. The entire python/notebook   will need to be stored/shared to reproduce a workflow.</li> </ul>"},{"location":"concepts/goals_and_alternatives/#alternatives-to-mismo","title":"Alternatives to Mismo","text":"<p>A useful way of describing Mismo is to compare it to other record linkage packages, and what I was trying to do differently.</p>"},{"location":"concepts/goals_and_alternatives/#dedupe","title":"Dedupe","text":"<p>Dedupe is pure python, Mismo uses SQL. Thus, Dedupe is able to implement some very complex algorithms that would be difficult to implement in SQL. However, Mismo is much much faster than Dedupe, and can handle much larger datasets.</p> <p>Dedupe is very opinionated, and therefore it is hard to extend. Once you give it your data, it does everything for you, and it is hard to insert your own steps in the middle. Mismo is more like a library of building blocks that you can compose together however you want.</p> <p>I find that Dedupe's way of saving/loading models was clunky and brittle. I wanted to make this more ergonomic.</p>"},{"location":"concepts/goals_and_alternatives/#splink","title":"Splink","text":"<p>Splink is a great package, and I learned a lot from it. That is one of the main sources of inspiration for Mismo.</p> <p>Like Mismo, Splink uses SQL. However, Splink uses raw SQL, whereas Mismo uses Ibis. I think the strongly typed, pythonic API of Ibis makes it much easier for you, as the user of Mismo, to write and maintain code than raw SQL. It also makes it much easier for me, as the maintainer of Mismo, to write the algorithms and tests.</p> <p>Splink only supports a small number of backends at the time of this wriing, but Ibis, and therefore Mismo, supports many more.</p> <p>Splink is very opinionated like Dedupe, and suffers from the same problems.</p> <p>I like how Splink persists model state in a plain json file, but I wish it would just store the learned weights in there. The parameters that don't change between runs, such as what comparisons to use, should be implemented in python to give you the most flexibility. I tried to do this in Mismo.</p>"},{"location":"concepts/goals_and_alternatives/#record-linkage-toolkit","title":"Record Linkage Toolkit","text":"<p>I really like how RLTK is more of a library than a framework. RLTK is more like sklearn, in the sense that it is a collection of tools that you can combine how you want. I wanted to emulate this. But in addition, I wanted to add a framework layer on top of this, so you could have an easy to get going and opinionated solution like Dedupe and Splink.</p> <p>RLTK uses pandas and numpy, so it suffers scaling limitations, because you can't work with data that is going to be larger than memory.</p> <p>I liked how the data structures RLTK expects/returns from its APIs were all standard stuff like pandas dataframes and numpy arrays. I tried to copy this as much as possible, and the result is that Mismo uses vanilla Ibis tables whenever possible.</p> <p>I didn't like how RLTK was so object oriented. It seems like you have to create an object to perform most tasks. These objects are also mutable, which makes it hard to keep track of their state. Whenever possible, I tried to use pure functions and immutable data structuress.</p>"},{"location":"concepts/goals_and_alternatives/#pyjedai","title":"PyJedAi","text":"<p>I don't know about this much. It looks similar to RLTK, except it implements many more algorithms, and looks more actively maintained. It is maintained by a group of researchers at University of Athens, so a lot of the algorithms are state of the art, and documented in related research papers.</p> <p>I hope to port many of the algorithms over from it, and take inspiration from their API.</p> <p>It's API is a bit \"heavy\" though, with a lot of classes, I'm guessing because it is a port from the original Java implementation. I want to make mismo's API more functional and lightweight.</p> <p>It also suffers from being based around pandas, so it inherintly isn't going to scale as well as using duckdb and ibis.</p>"},{"location":"concepts/goals_and_alternatives/#dblink","title":"DBLink","text":"<p>Bayesian, unsupervised record linkage on structured data using Apache Spark.</p> <p>Maybe a bit more academic and not production ready. Development has ceased. Has some interesting algorithms and ideas on how to do things.</p>"},{"location":"concepts/versioning/","title":"Versioning, Support, and Deprecation Policy","text":"<p>Mismo is currently in alpha and breaking changes may happen at any time. In the future, we will follow the ideas outlines below:</p> <p>Mismo considers everything documented in these docs to be part of the public API. If it's not in the docs, breaking changes may happen at any time.</p> <p>Mismo follows NEP29 for python version support.</p>"},{"location":"examples/address_linkage/","title":"Address linkage","text":""},{"location":"examples/patent_deduplication/","title":"Patent Deduplication","text":""},{"location":"reference/arrays/","title":"Array Utils","text":""},{"location":"reference/arrays/#array-transformations","title":"Array Transformations","text":""},{"location":"reference/arrays/#mismo.arrays.array_shuffle","title":"mismo.arrays.array_shuffle","text":"<pre><code>array_shuffle(a: ArrayValue) -&gt; ArrayValue\n</code></pre> <p>Shuffle an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_choice","title":"mismo.arrays.array_choice","text":"<pre><code>array_choice(a: ArrayValue, n: int) -&gt; ArrayValue\n</code></pre> <p>Randomly select <code>n</code> elements from an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_combinations","title":"mismo.arrays.array_combinations","text":"<pre><code>array_combinations(\n    left: ArrayValue, right: ArrayValue\n) -&gt; ArrayValue\n</code></pre> <p>Generate all combinations of elements from two arrays.</p> <p>This is the cartesian product of the two arrays.</p> PARAMETER DESCRIPTION <code>left</code> <p>The first array.</p> <p> TYPE: <code>ArrayValue</code> </p> <code>right</code> <p>The second array.</p> <p> TYPE: <code>ArrayValue</code> </p> RETURNS DESCRIPTION <code>combinations</code> <p>An <code>array&lt;struct&lt;l: T, r: U&gt;&gt;</code> where <code>T</code> is the type of the elements in <code>array1</code> and <code>U</code> is the type of the elements in <code>array2</code>.</p>"},{"location":"reference/arrays/#mismo.arrays.array_filter_isin_other","title":"mismo.arrays.array_filter_isin_other","text":"<pre><code>array_filter_isin_other(\n    t: Table,\n    array: ArrayColumn | str,\n    other: Column,\n    *,\n    result_format: str = \"{name}_filtered\",\n) -&gt; Table\n</code></pre> <p>Equivalent to <code>t.mutate(result_name=t[array].filter(lambda x: x.isin(other)))</code></p> <p>We can't have subqueries in the filter lambda (need this to avoid https://stackoverflow.com/questions/77559936/how-to-implementlist-filterarray-elem-elem-in-column-in-other-table))</p> <p>See issues/32 for more info.</p> PARAMETER DESCRIPTION <code>t</code> <p>The table containing the array column.</p> <p> TYPE: <code>Table</code> </p> <code>array</code> <p>A reference to the array column.</p> <p> TYPE: <code>ArrayColumn | str</code> </p> <code>other</code> <p>The column to filter against.</p> <p> TYPE: <code>Column</code> </p> <code>result_format</code> <p>The format string to use for the result column name. The format string should have a single placeholder, <code>{name}</code>, which will be replaced with the name of the array column.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{name}_filtered'</code> </p> RETURNS DESCRIPTION <code>Table</code> <p>The table with a new column named following <code>result_format</code> with the filtered array.</p>"},{"location":"reference/arrays/#array-aggregations","title":"Array Aggregations","text":""},{"location":"reference/arrays/#mismo.arrays.array_any","title":"mismo.arrays.array_any","text":"<pre><code>array_any(array) -&gt; bool\n</code></pre> <p>Return True if any elements in the array are True, False otherwise.</p> <p>NULL values are ignored. If there are no non-NULL values, returns NULL.</p>"},{"location":"reference/arrays/#mismo.arrays.array_all","title":"mismo.arrays.array_all","text":"<pre><code>array_all(array) -&gt; bool\n</code></pre> <p>Return True if all elements in the array are True, False otherwise.</p> <p>NULL values are ignored. If there are no non-NULL values, returns NULL.</p>"},{"location":"reference/arrays/#mismo.arrays.array_min","title":"mismo.arrays.array_min","text":"<pre><code>array_min(array: ArrayValue) -&gt; NumericValue\n</code></pre> <p>Get the minimum value of an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_max","title":"mismo.arrays.array_max","text":"<pre><code>array_max(array: ArrayValue) -&gt; NumericValue\n</code></pre> <p>Get the maximum value of an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_mean","title":"mismo.arrays.array_mean","text":"<pre><code>array_mean(array: ArrayValue) -&gt; FloatingValue\n</code></pre> <p>Get the mean value of an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_median","title":"mismo.arrays.array_median","text":"<pre><code>array_median(array: ArrayValue) -&gt; FloatingValue\n</code></pre> <p>Get the median value of an array.</p>"},{"location":"reference/arrays/#mismo.arrays.array_sum","title":"mismo.arrays.array_sum","text":"<pre><code>array_sum(array: ArrayValue) -&gt; NumericValue\n</code></pre> <p>Get the sum of all values of an array.</p>"},{"location":"reference/cluster/","title":"Clustering API","text":"<p>After we have compared pairs of records, we need to somehow resolve these links into groups of records that are all the same entity. This is done with various graph algorithms, which are implemented in this module.</p>"},{"location":"reference/cluster/#algorithms","title":"Algorithms","text":""},{"location":"reference/cluster/#mismo.cluster.connected_components","title":"mismo.cluster.connected_components","text":"<pre><code>connected_components(\n    *,\n    links: Table,\n    records: Column | Table | None,\n    max_iter: int | None = None,\n    label_as: str = \"component\",\n) -&gt; Table\n</code></pre><pre><code>connected_components(\n    *,\n    links: Table,\n    records: Iterable[Table] | Mapping[str, Table],\n    max_iter: int | None = None,\n    label_as: str = \"component\",\n) -&gt; Datasets\n</code></pre> <pre><code>connected_components(\n    *,\n    links: Table,\n    records: Column\n    | Table\n    | Iterable[Table]\n    | Mapping[str, Table] = None,\n    max_iter: int | None = None,\n    label_as: str = \"component\",\n) -&gt; Table | Datasets\n</code></pre> <p>Label records using connected components, based on the given links.</p> <p>This uses an iterative algorithm that is linear in terms of the diameter of the largest component (ie how many \"hops\" it takes to get from one end of a cluster to the other). This is usually acceptable for our use case, because we expect the components to be small.</p> PARAMETER DESCRIPTION <code>links</code> <p>A table with the columns (record_id_l, record_id_r), corresponding to the <code>record_id</code>s in <code>records</code>.</p> <p> TYPE: <code>Table</code> </p> <code>records</code> <p>Table(s) of records with at least the column <code>record_id</code>, the column of record_ids itself, or None.</p> <p>Note</p> <p>If you supply multiple Tables, the record_ids must be the same type across all tables, and universally unique across all tables</p> <p> TYPE: <code>Column | Table | Iterable[Table] | Mapping[str, Table]</code> DEFAULT: <code>None</code> </p> <code>max_iter</code> <p>The maximum number of iterations to run. If None, run until convergence.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>label_as</code> <p>The name of the label column that will contain the component ID.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'component'</code> </p> RETURNS DESCRIPTION <code>result</code> <ul> <li>If <code>records</code> is None, a Table will be returned with columns <code>record_id</code> and <code>&lt;label_as&gt;</code> of type <code>int64</code> that maps record_id to component.</li> <li>If <code>records</code> is a single Table, that table will be returned with a <code>&lt;label_as&gt; column added of type</code>int64`.</li> <li>If <code>records</code> is an iterable/mapping of Tables, a <code>Datasets</code> will be returned, with a <code>&lt;label_as&gt;</code> column of type <code>int64</code> added to each contained Table.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from mismo.cluster import connected_components\n&gt;&gt;&gt; records1 = ibis.memtable(\n...     [\n...         (\"a\", 0),\n...         (\"b\", 1),\n...         (\"c\", 2),\n...         (\"d\", 3),\n...         (\"g\", 6),\n...     ],\n...     columns=[\"record_id\", \"other\"],\n... )\n&gt;&gt;&gt; records2 = ibis.memtable(\n...     [\n...         (\"h\", 7),\n...         (\"x\", 23),\n...         (\"y\", 24),\n...         (\"z\", 25),\n...     ],\n...     columns=[\"record_id\", \"other\"],\n... )\n&gt;&gt;&gt; links = ibis.memtable(\n...     [\n...         (\"a\", \"x\"),\n...         (\"b\", \"x\"),\n...         (\"b\", \"y\"),\n...         (\"c\", \"y\"),\n...         (\"c\", \"z\"),\n...         (\"g\", \"h\"),\n...     ],\n...     columns=[\"record_id_l\", \"record_id_r\"],\n... )\n</code></pre> <p>If you don't supply the records, then you just get a labeling map from record_id -&gt; component. Note how only the record_ids that are present in <code>links</code> are returned, eg there is no record_id <code>\"d\"</code> present:</p> <pre><code>&gt;&gt;&gt; connected_components(links=links).order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 component \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a         \u2502         0 \u2502\n\u2502 b         \u2502         0 \u2502\n\u2502 c         \u2502         0 \u2502\n\u2502 g         \u2502         3 \u2502\n\u2502 h         \u2502         3 \u2502\n\u2502 x         \u2502         0 \u2502\n\u2502 y         \u2502         0 \u2502\n\u2502 z         \u2502         0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you supply records, then the records are labeled with the component. We can also change the name of the column that contains the component:</p> <pre><code>&gt;&gt;&gt; connected_components(\n...     records=records1,\n...     links=links,\n...     label_as=\"label\",\n... ).order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 other \u2503 label \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a         \u2502     0 \u2502     0 \u2502\n\u2502 b         \u2502     1 \u2502     0 \u2502\n\u2502 c         \u2502     2 \u2502     0 \u2502\n\u2502 d         \u2502     3 \u2502     4 \u2502\n\u2502 g         \u2502     6 \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>You can supply multiple sets of records, which are coerced to a <code>Datasets</code>, and returned as a <code>Datasets</code>, with each table of records labeled individually.</p> <pre><code>&gt;&gt;&gt; a, b = connected_components(records=(records1, records2), links=links)\n&gt;&gt;&gt; a.order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 other \u2503 component \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64 \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a         \u2502     0 \u2502         0 \u2502\n\u2502 b         \u2502     1 \u2502         0 \u2502\n\u2502 c         \u2502     2 \u2502         0 \u2502\n\u2502 d         \u2502     3 \u2502         4 \u2502\n\u2502 g         \u2502     6 \u2502         3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; b.order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 other \u2503 component \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 int64 \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 h         \u2502     7 \u2502         3 \u2502\n\u2502 x         \u2502    23 \u2502         0 \u2502\n\u2502 y         \u2502    24 \u2502         0 \u2502\n\u2502 z         \u2502    25 \u2502         0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/cluster/#mismo.cluster.degree","title":"mismo.cluster.degree","text":"<pre><code>degree(*, links: Table, records: Table | None) -&gt; Table\n</code></pre><pre><code>degree(\n    *,\n    links: Table,\n    records: Iterable[Table] | Mapping[str, Table],\n) -&gt; Datasets\n</code></pre> <pre><code>degree(\n    *,\n    links: Table,\n    records: Table\n    | Iterable[Table]\n    | Mapping[str, Table]\n    | None = None,\n) -&gt; Table | Datasets\n</code></pre> <p>Label records with their degree (number of links to other records).</p> <p>This is the graph theory definition of degree, i.e. the number of vertices coming into or out of a vertex. In this case, the number of links coming into or out of a record.</p> PARAMETER DESCRIPTION <code>links</code> <p>A table of edges with at least columns (record_id_l, record_id_r).</p> <p> TYPE: <code>Table</code> </p> <code>records</code> <p>Table(s) of records with at least the column <code>record_id</code>, or None.</p> <p> TYPE: <code>Table | Iterable[Table] | Mapping[str, Table] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>result</code> <p>If <code>records</code> is None, a Table will be returned with columns <code>record_id</code> and <code>degree:uint64</code> that maps record_id to a degree. If <code>records</code> is a single Table, that table will be returned with a <code>degree:uint64</code> column added. If an iterable/mapping of Tables is given, a <code>Datasets</code> will be returned, with a <code>component</code> column added to each contained Table.</p>"},{"location":"reference/cluster/#evaluation","title":"Evaluation","text":"<p>Utilities for assessing the quality of a linkage result.</p>"},{"location":"reference/cluster/#mismo.cluster.mutual_info_score","title":"mismo.cluster.mutual_info_score","text":"<pre><code>mutual_info_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>Compute the mutual information between two clusterings.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.mutual_info_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.adjusted_mutual_info_score","title":"mismo.cluster.adjusted_mutual_info_score","text":"<pre><code>adjusted_mutual_info_score(\n    labels_true: Table,\n    labels_pred: Table,\n    *,\n    average_method: Literal[\n        \"arithmetic\", \"geometric\", \"min\", \"max\"\n    ] = \"arithmetic\",\n) -&gt; float\n</code></pre> <p>Adjusted Mutual Information between two clusterings.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.adjusted_mutual_info_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.normalized_mutual_info_score","title":"mismo.cluster.normalized_mutual_info_score","text":"<pre><code>normalized_mutual_info_score(\n    labels_true: Table,\n    labels_pred: Table,\n    *,\n    average_method: Literal[\n        \"arithmetic\", \"geometric\", \"min\", \"max\"\n    ] = \"arithmetic\",\n) -&gt; float\n</code></pre> <p>Compute the normalized mutual information between two clusterings.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.normalized_mutual_info_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.rand_score","title":"mismo.cluster.rand_score","text":"<pre><code>rand_score(labels_true: Table, labels_pred: Table) -&gt; float\n</code></pre> <p>Compute the Rand Index between two clusterings.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.rand_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.adjusted_rand_score","title":"mismo.cluster.adjusted_rand_score","text":"<pre><code>adjusted_rand_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>Adjusted Rand Index between two clusterings.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.adjusted_rand_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.fowlkes_mallows_score","title":"mismo.cluster.fowlkes_mallows_score","text":"<pre><code>fowlkes_mallows_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>Measure the similarity of two clusterings of a set of points.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.fowlkes_mallows_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.homogeneity_score","title":"mismo.cluster.homogeneity_score","text":"<pre><code>homogeneity_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>Homogeneity metric of a cluster labeling given a ground truth.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.homogeneity_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.completeness_score","title":"mismo.cluster.completeness_score","text":"<pre><code>completeness_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>Compute completeness metric of a cluster labeling given a ground truth.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.completeness_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.v_measure_score","title":"mismo.cluster.v_measure_score","text":"<pre><code>v_measure_score(\n    labels_true: Table, labels_pred: Table\n) -&gt; float\n</code></pre> <p>V-measure metric of a cluster labeling given a ground truth.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.v_measure_score for more information.</p>"},{"location":"reference/cluster/#mismo.cluster.homogeneity_completeness_v_measure","title":"mismo.cluster.homogeneity_completeness_v_measure","text":"<pre><code>homogeneity_completeness_v_measure(\n    labels_true: Table,\n    labels_pred: Table,\n    *,\n    beta: float = 1.0,\n) -&gt; tuple[float, float, float]\n</code></pre> <p>Compute the homogeneity, completeness, and V-measure scores at once.</p> <p>The two input tables must have columns \"record_id\" and \"label\", a map from record ID to cluster label. They must have the same record IDs.</p> <p>See sklearn.metrics.homogeneity_completeness_v_measure for more information.</p>"},{"location":"reference/cluster/#plot","title":"Plot","text":""},{"location":"reference/cluster/#mismo.cluster.degree_dashboard","title":"mismo.cluster.degree_dashboard","text":"<pre><code>degree_dashboard(\n    tables: Table | Iterable[Table] | Mapping[str, Table],\n    links: Table,\n) -&gt; Componenta\n</code></pre> <p>Make a dashboard for exploring the degree (number of links) of records.</p> <p>The \"degree\" of a record is the number of other records it is linked to.</p> <p>Pass the entire dataset and the links between records, and use this to explore the distribution of degrees.</p>"},{"location":"reference/cluster/#mismo.cluster.cluster_dashboard","title":"mismo.cluster.cluster_dashboard","text":"<pre><code>cluster_dashboard(\n    ds: Datasets\n    | Table\n    | Iterable[Table]\n    | Mapping[str, Table],\n    links: Table,\n) -&gt; Column\n</code></pre> <p>A Solara component for that shows a cluster of records and links.</p> <p>This shows ALL the supplied records and links, so be careful, you probably want to filter them down first. You can use the <code>clusters_dashboard</code> component for that.</p> <p>This is like <code>cytoscape_widget</code>, but with a status bar that shows information about the selected node or edge.</p> PARAMETER DESCRIPTION <code>ds</code> <p>Table(s) of records with at least the column <code>record_id</code>.</p> <p> TYPE: <code>Datasets | Table | Iterable[Table] | Mapping[str, Table]</code> </p> <code>links</code> <p>A table of edges with at least columns (record_id_l, record_id_r) and optionally other columns. The column <code>width</code> is used to set the width of the edges. If not given, it is determined from the column <code>odds</code>, if present, or set to 5 otherwise. The column <code>opacity</code> is used to set the opacity of the edges. If not given, it is set to 0.5.</p> <p> TYPE: <code>Table</code> </p>"},{"location":"reference/cluster/#mismo.cluster.clusters_dashboard","title":"mismo.cluster.clusters_dashboard","text":"<pre><code>clusters_dashboard(\n    tables: Datasets\n    | Table\n    | Iterable[Table]\n    | Mapping[str, Table],\n    links: Table,\n) -&gt; Column\n</code></pre> <p>Make a dashboard for exploring different clusters of records.</p> <p>Pass the entire dataset and the links between records, and use this to filter down to a particular cluster.</p>"},{"location":"reference/compare/","title":"Comparing API","text":"<p>Once records are blocked together into pairs, we actually can do pairwise comparisons on them.</p> <p>All of the APIs revolve around the  protocol. This is simply a function which takes a table of record pairs, (eg with columns suffixed with <code>_l</code> and <code>_r</code>), and returns a modified version of this table. For example, it could add a column with match scores, add rows that were missed during the initial blocking, or remove rows that we no longer want to consider as matched.</p>"},{"location":"reference/compare/#mismo.compare.PComparer","title":"mismo.compare.PComparer","text":"<p>               Bases: <code>Protocol</code></p> <p>A Callable that adds column(s) of features to a table of record pairs.</p>"},{"location":"reference/compare/#mismo.compare.PComparer.__call__","title":"mismo.compare.PComparer.__call__","text":"<pre><code>__call__(pairs: Table, **kwargs) -&gt; Table\n</code></pre> <p>Add column(s) of features to a table of record pairs.</p> <p>For example, add a match score to each record pair, modify a score from a previous PComparer, or similar.</p> <p>Implementers must expect to be called with a table of record pairs. Columns suffixed with \"_l\" come from the left table, columns suffixed with \"_r\" come from the right table, and columns with neither suffix are features of the pair itself (eg from a different PComparer).</p>"},{"location":"reference/compare/#level-based-comparers","title":"Level-Based Comparers","text":"<p>Bin record pairs into discrete levels, based on levels of agreement.</p> <p>Each LevelComparer represents a dimension, such as name, location, price, date, etc. Each one contains many MatchLevels, each of which is a level of aggreement, such as exact, misspelling, within_1_km, etc.</p>"},{"location":"reference/compare/#mismo.compare.MatchLevel","title":"mismo.compare.MatchLevel","text":"<p>An enum-like class for match levels.</p> <p>This class is used to define the levels of agreement between two records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from mismo.compare import MatchLevel\n&gt;&gt;&gt; class NameMatchLevel(MatchLevel):\n...     EXACT = 0\n...     NEAR = 1\n...     ELSE = 2\n</code></pre> <p>The class acts as a container:</p> <pre><code>&gt;&gt;&gt; len(NameMatchLevel)\n3\n&gt;&gt;&gt; 2 in NameMatchLevel\nTrue\n&gt;&gt;&gt; list(NameMatchLevel)\n['EXACT', 'NEAR', 'ELSE']\n</code></pre> <p>You can access the hardcoded values:</p> <pre><code>&gt;&gt;&gt; str(NameMatchLevel.EXACT)\n'EXACT'\n&gt;&gt;&gt; int(NameMatchLevel.EXACT)\n0\n</code></pre> <p>You can use indexing semantics to translate between strings and ints:</p> <pre><code>&gt;&gt;&gt; NameMatchLevel[1]\n'NEAR'\n&gt;&gt;&gt; NameMatchLevel[\"NEAR\"]\n1\n&gt;&gt;&gt; NameMatchLevel[ibis.literal(1)].execute()\n'NEAR'\n&gt;&gt;&gt; NameMatchLevel[ibis.literal(\"NEAR\")].execute()\n1\n</code></pre> <p>You can construct your own values, both from python literals...</p> <pre><code>&gt;&gt;&gt; NameMatchLevel(\"NEAR\").as_integer()\n1\n&gt;&gt;&gt; NameMatchLevel(2).as_string()\n'ELSE'\n&gt;&gt;&gt; NameMatchLevel(3)\nTraceback (most recent call last):\n...\nValueError: Invalid value: 3. Must be one of {0, 1, 2}`\n</code></pre> <p>...And Ibis expressions</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; levels_raw = ibis.array([0, 2, 1, 99]).unnest()\n&gt;&gt;&gt; levels = NameMatchLevel(levels_raw)\n&gt;&gt;&gt; levels.as_string().execute()\n0    EXACT\n1     ELSE\n2     NEAR\n3     None\nName: NameMatchLevel, dtype: object\n&gt;&gt;&gt; levels.as_integer().name(\"levels\").execute()\n0     0\n1     2\n2     1\n3    99\nName: levels, dtype: int8\n</code></pre> <p>Comparisons work as you expect:</p> <pre><code>&gt;&gt;&gt; NameMatchLevel.NEAR == 1\nTrue\n&gt;&gt;&gt; NameMatchLevel(1) == \"NEAR\"\nTrue\n&gt;&gt;&gt; (levels_raw == NameMatchLevel.NEAR).name(\"eq\").execute()\n0    False\n1    False\n2     True\n3    False\nName: eq, dtype: bool\n</code></pre> <p>However, implicit ordering is not supported (file an issue if you think it should be):</p> <pre><code>&gt;&gt;&gt; NameMatchLevel.NEAR &gt; 0\nTraceback (most recent call last):\n...\nTypeError: '&gt;' not supported between instances of 'NameMatchLevel' and 'int'\n</code></pre>"},{"location":"reference/compare/#mismo.compare.MatchLevel.__eq__","title":"mismo.compare.MatchLevel.__eq__","text":"<pre><code>__eq__(\n    other: int\n    | str\n    | NumericValue\n    | StringValue\n    | MatchLevel,\n) -&gt; bool | BooleanValue\n</code></pre>"},{"location":"reference/compare/#mismo.compare.MatchLevel.__init__","title":"mismo.compare.MatchLevel.__init__","text":"<pre><code>__init__(\n    value: MatchLevel\n    | int\n    | str\n    | StringValue\n    | IntegerValue,\n)\n</code></pre> <p>Create a new match level value.</p> <p>If the given value is a python int or str, it is checked against the valid values for this class. If it is an ibis expression, we do no such check.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value of the match level.</p> <p> TYPE: <code>MatchLevel | int | str | StringValue | IntegerValue</code> </p>"},{"location":"reference/compare/#mismo.compare.MatchLevel.as_integer","title":"mismo.compare.MatchLevel.as_integer","text":"<pre><code>as_integer() -&gt; int | IntegerValue\n</code></pre> <p>Convert to a python int or ibis integer, depending on the original type.</p>"},{"location":"reference/compare/#mismo.compare.MatchLevel.as_string","title":"mismo.compare.MatchLevel.as_string","text":"<pre><code>as_string() -&gt; str | StringValue\n</code></pre> <p>Convert to a python str or ibis string, depending on the original type.</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer","title":"mismo.compare.LevelComparer","text":"<p>               Bases: <code>Generic[MatchLevelT]</code></p> <p>Assigns a MatchLevel to record pairs based on one dimension, e.g. name</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer.cases","title":"mismo.compare.LevelComparer.cases  <code>instance-attribute</code>","text":"<pre><code>cases: tuple[tuple[BooleanColumn, MatchLevelT], ...]\n</code></pre> <p>The cases to check for each level.</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer.levels","title":"mismo.compare.LevelComparer.levels  <code>instance-attribute</code>","text":"<pre><code>levels: Type[MatchLevelT]\n</code></pre> <p>The levels of agreement.</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer.name","title":"mismo.compare.LevelComparer.name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the comparer, eg \"date\", \"address\", \"latlon\", \"price\".</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer.representation","title":"mismo.compare.LevelComparer.representation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>representation: Literal['string', 'integer'] = 'integer'\n</code></pre> <p>The native representation of the levels in ibis expressions.</p> <p>Integers are more performant, but strings are more human-readable.</p>"},{"location":"reference/compare/#mismo.compare.LevelComparer.__call__","title":"mismo.compare.LevelComparer.__call__","text":"<pre><code>__call__(\n    pairs: Table,\n    *,\n    representation: Literal[\"string\", \"integer\"]\n    | None = None,\n) -&gt; StringColumn | IntegerColumn\n</code></pre> <p>Label each record pair with the level that it matches.</p> <p>Go through the levels in order. If a record pair matches a level, label ir. If none of the levels match a pair, it labeled as \"else\".</p> PARAMETER DESCRIPTION <code>pairs</code> <p>A table of record pairs.</p> <p> TYPE: <code>Table</code> </p> RETURNS DESCRIPTION <code>labels</code> <p>The labels for each record pair.</p> <p> TYPE: <code>StringColumn</code> </p>"},{"location":"reference/compare/#plotting","title":"Plotting","text":""},{"location":"reference/compare/#mismo.compare.compared_dashboard","title":"mismo.compare.compared_dashboard","text":"<pre><code>compared_dashboard(\n    compared: Table,\n    comparers: Iterable[LevelComparer],\n    weights: Weights | None = None,\n    *,\n    width: int = 500,\n) -&gt; VBox\n</code></pre> <p>A dashboard for debugging compared record pairs.</p> <p>Used to see which match levels are common, which are rare, and which Comparers are related to each other. For example, exact matches should appear together across all Comparers, this probably represents true matches.</p> PARAMETER DESCRIPTION <code>compared</code> <p>The result of running the blocked table through the supplied <code>comparers</code>.</p> <p> TYPE: <code>Table</code> </p> <code>comparers</code> <p>The LevelCompareres that were used to compare <code>compared</code>.</p> <p> TYPE: <code>Iterable[LevelComparer]</code> </p> <code>weights</code> <p>The Weights used to score the comparers. If provided, the chart will be colored by the odds found from the Weights.</p> <p> TYPE: <code>Weights | None</code> DEFAULT: <code>None</code> </p> <code>width</code> <p>The width of the chart.</p> <p> TYPE: <code>int</code> DEFAULT: <code>500</code> </p> RETURNS DESCRIPTION <code>VBox</code> <p>The dashboard.</p>"},{"location":"reference/core/","title":"Core API","text":"<p>Types, functions, etc that are core to mismo and are used throughout the rest of the framework</p>"},{"location":"reference/core/#core-types","title":"Core Types","text":""},{"location":"reference/core/#mismo.Linkage","title":"mismo.Linkage","text":"<p>A dataclass of two Tables of records (LinkedTables) and a Table of links (LinksTable) between them.</p> <p>Each record in <code>left</code> can be linked from 0 to N records in <code>right</code>, and vice versa.</p> See Also <p>The Diff dataclass, for representing the special case where each record is linked to at most one other record.</p>"},{"location":"reference/core/#mismo.Linkage.left","title":"mismo.Linkage.left  <code>property</code>","text":"<pre><code>left: LinkedTable\n</code></pre> <p>The left Table.</p>"},{"location":"reference/core/#mismo.Linkage.links","title":"mismo.Linkage.links  <code>property</code>","text":"<pre><code>links: LinksTable\n</code></pre> <p>A table of (record_id_l, record_id_r, ...) that link <code>left</code> and <code>right</code>."},{"location":"reference/core/#mismo.Linkage.right","title":"mismo.Linkage.right  <code>property</code>","text":"<pre><code>right: LinkedTable\n</code></pre> <p>The right Table.</p>"},{"location":"reference/core/#mismo.Linkage.__init__","title":"mismo.Linkage.__init__","text":"<pre><code>__init__(\n    *, left: Table, right: Table, links: Table\n) -&gt; None\n</code></pre> <p>Create from two Tables and a Table of links between them.</p> PARAMETER DESCRIPTION <code>left</code> <p>A Table of records, with at least a column 'record_id'.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>A Table of records, with at least a     column 'record_id'.</p> <p> TYPE: <code>Table</code> </p> <code>links</code> <p>A Table of links between the two tables. Must have columns 'record_id_l' and 'record_id_r', which refer to the 'record_id' columns in <code>left</code> and <code>right</code>, respectively. May have other columns. May not have duplicate (record_id_l, record_id_r) pairs.</p> <p> TYPE: <code>Table</code> </p>"},{"location":"reference/core/#mismo.Linkage.cache","title":"mismo.Linkage.cache","text":"<pre><code>cache() -&gt; Self\n</code></pre> <p>Cache left, right, and links for faster subsequent access.</p>"},{"location":"reference/core/#mismo.Linkage.copy","title":"mismo.Linkage.copy","text":"<pre><code>copy(\n    *,\n    left: LinkedTable | None = None,\n    right: LinkedTable | None = None,\n    links: LinksTable | None = None,\n) -&gt; Linkage\n</code></pre> <p>Create a new Linkage, optionally replacing the left, right, and links tables.</p>"},{"location":"reference/core/#mismo.Linkage.from_join_condition","title":"mismo.Linkage.from_join_condition  <code>classmethod</code>","text":"<pre><code>from_join_condition(\n    left: Table, right: Table, condition: Any\n) -&gt; Self\n</code></pre> <p>Create a Linkage from two Tables and a join condition.</p> PARAMETER DESCRIPTION <code>left</code> <p>A Table of records, with at least a column 'record_id'.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>A Table of records, with at least a column 'record_id'.</p> <p> TYPE: <code>Table</code> </p> <code>condition</code> <p>A join condition, such as a boolean expression or an ibis expression. See mismo.join_condition for more details.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>    A Linkage object.</code>"},{"location":"reference/core/#mismo.Linkage.from_parquets","title":"mismo.Linkage.from_parquets  <code>classmethod</code>","text":"<pre><code>from_parquets(\n    directory: str | Path,\n    /,\n    *,\n    backend: BaseBackend | None = None,\n) -&gt; Self\n</code></pre> <p>Create a Linkage by reading parquets from the given directory.</p>"},{"location":"reference/core/#mismo.Linkage.link_counts_chart","title":"mismo.Linkage.link_counts_chart","text":"<pre><code>link_counts_chart() -&gt; Chart\n</code></pre> <p>A side by side altair Chart of <code>left.link_counts().chart()</code> and <code>right.link_counts().chart()</code>.</p> <pre><code>Number of           Left Table               Number of    Right Table\n  Records                                      Records\n        |    \u2588                                       |    \u2588\n100,000 | \u2588  \u2588                                       |    \u2588\n        | \u2588  \u2588                                10,000 |    \u2588\n        | \u2588  \u2588  \u2588                                    |    \u2588\n 10,000 | \u2588  \u2588  \u2588                                    |    \u2588  \u2588\n        | \u2588  \u2588  \u2588                                    | \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588                              1,000 | \u2588  \u2588  \u2588\n  1,000 | \u2588  \u2588  \u2588  \u2588                                 | \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588                           | \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588                        | \u2588  \u2588  \u2588  \u2588\n    100 | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588              100 | \u2588  \u2588  \u2588  \u2588\n        | 0  1  2  3  4 10 12 14 23                  | 0  1  2  3\n        Number of Links                              Number of Links\n</code></pre>"},{"location":"reference/core/#mismo.Linkage.to_parquets","title":"mismo.Linkage.to_parquets","text":"<pre><code>to_parquets(\n    directory: str | Path, /, *, overwrite: bool = False\n) -&gt; None\n</code></pre> <p>Write left, right, and links to parquet files in the given directory.</p>"},{"location":"reference/core/#mismo.LinkedTable","title":"mismo.LinkedTable","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A table of records that are linked to another table.</p> <p>Each record here can be linked to 0-N records in the <code>other_</code>.</p> <p>This acts just like an Ibis Table, but it has a few extra attributes and methods that make it more ergonomic to work with, eg to add data from the linked table.</p>"},{"location":"reference/core/#mismo.LinkedTable.links_","title":"mismo.LinkedTable.links_  <code>property</code>","text":"<pre><code>links_: LinksTable\n</code></pre> <p>The table of links between this table and <code>other</code>.</p> <p>Trailing underscore to avoid name conflicts with column names.</p>"},{"location":"reference/core/#mismo.LinkedTable.other_","title":"mismo.LinkedTable.other_  <code>property</code>","text":"<pre><code>other_: Self\n</code></pre> <p>The other table that this table is linked to.</p> <p>Trailing underscore to avoid name conflicts with column names.</p>"},{"location":"reference/core/#mismo.LinkedTable.link_counts","title":"mismo.LinkedTable.link_counts","text":"<pre><code>link_counts() -&gt; LinkCountsTable\n</code></pre> <p>Describes 'There are <code>n_records</code> in self that linked to <code>n_links</code> in `other'.</p> <p>This is basically a histogram of <code>self.with_n_links()</code></p> See Also <p>with_n_links</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import mismo\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; left = ibis.memtable({\"record_id\": [4, 5, 6]})\n&gt;&gt;&gt; right = ibis.memtable({\"record_id\": [7, 8, 9]})\n&gt;&gt;&gt; links = ibis.memtable({\"record_id_l\": [4, 4, 5], \"record_id_r\": [7, 8, 9]})\n&gt;&gt;&gt; linkage = mismo.Linkage(left=left, right=right, links=links)\n</code></pre> <p>There is 1 record in left (6) that didn't match any in right. There is 1 record in left (5) that matched 1 in right. There is 1 record in left (4) that matched 2 in right.</p> <pre><code>&gt;&gt;&gt; linkage.left.link_counts().order_by(\"n_links\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 n_links \u2503 n_records \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       0 \u2502         1 \u2502\n\u2502       1 \u2502         1 \u2502\n\u2502       2 \u2502         1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>All 3 records in right matched 1 in left.</p> <pre><code>&gt;&gt;&gt; linkage.right.link_counts()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 n_links \u2503 n_records \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64   \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502       1 \u2502         3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.LinkedTable.make_pair","title":"mismo.LinkedTable.make_pair  <code>classmethod</code>","text":"<pre><code>make_pair(\n    *, left: Table, right: Table, links: Table\n) -&gt; tuple[Self, Self]\n</code></pre> <p>Create a pair of LinkedTables from left, right, and links.</p> <p>This basically just wraps the logic to make it so that the the _l and _r suffixes in the links table are consistent.</p>"},{"location":"reference/core/#mismo.LinkedTable.with_linked_values","title":"mismo.LinkedTable.with_linked_values","text":"<pre><code>with_linked_values(\n    *values: Deferred | Callable[[Table], Value] | None,\n    default_agg: Deferred = collect(),\n    **named_values: Deferred\n    | Callable[[Table], Value]\n    | None,\n) -&gt; Self\n</code></pre> <p>This table, with values from the linked records.</p> <p>See the examples below, this is easy to understand with examples, but hard to describe.</p> PARAMETER DESCRIPTION <code>values</code> <p>unnamed values</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>()</code> </p> <code>named_values</code> <p>named values</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>A new LinkedTable with new columns of values from the linked records.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; this = ibis.memtable({\"record_id\": [40, 50, 60], \"x\": [\"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; other = ibis.memtable({\"record_id\": [41, 42, 51], \"y\": [4.1, 4.2, 9.0]})\n&gt;&gt;&gt; links = ibis.memtable(\n...     {\"record_id_l\": [40, 40, 50], \"record_id_r\": [41, 42, 51]}\n... )\n&gt;&gt;&gt; lt = LinkedTable(this, other=other, links=links)\n&gt;&gt;&gt; lt\nLinkedTable&lt;3 records, 3 links&gt;\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 x      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 string \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        40 \u2502 a      \u2502\n\u2502        50 \u2502 b      \u2502\n\u2502        60 \u2502 c      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Select exactly which values you want from <code>other</code> Since every record in <code>self</code> can be linked to 0-N records in <code>other</code>, we need a way of aggregating the 0-N linked values in <code>other</code> to a single value. By default, if the given expression is not an aggregate, we default to <code>.collect()</code> to combine them all into an array. If the given expression is already an aggregate, then it is kept as-is.</p> <p>This uses the same semantics as <code>ibis.Table.select(*values, **named_values)</code>.</p> <pre><code>&gt;&gt;&gt; lt.with_linked_values(\n...     \"y\",\n...     ibis._.y.max().name(\"y_max\"),\n...     others=\"record_id\",\n...     other=ibis._.record_id.arbitrary(),\n... )\nLinkedTable&lt;3 records, 3 links&gt;\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 x      \u2503 y                    \u2503 y_max   \u2503 others               \u2503 other \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 string \u2502 array&lt;float64&gt;       \u2502 float64 \u2502 array&lt;int64&gt;         \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        40 \u2502 a      \u2502 [4.1, 4.2]           \u2502     4.2 \u2502 [41, 42]             \u2502    41 \u2502\n\u2502        50 \u2502 b      \u2502 [9.0]                \u2502     9.0 \u2502 [51]                 \u2502    51 \u2502\n\u2502        60 \u2502 c      \u2502 NULL                 \u2502    NULL \u2502 NULL                 \u2502  NULL \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>One common use case for this is during the task of a lookup. I want to see the record id of the linked record, exluding when there are no links and when there are multiple (ie ambiguous) links.</p> <pre><code>&gt;&gt;&gt; lt.with_n_links().with_linked_values(\n...     ibis._.record_id.arbitrary().name(\"record_id_other\"),\n... ).filter(ibis._.n_links == 1)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 x      \u2503 n_links \u2503 record_id_other \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 string \u2502 int64   \u2502 int64           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        50 \u2502 b      \u2502       1 \u2502              51 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If no values are provided, we will by default add a column named <code>other</code> with all the values from other packed into an array of structs.</p> <pre><code>&gt;&gt;&gt; lt.with_linked_values()\nLinkedTable&lt;3 records, 3 links&gt;\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 x      \u2503 other                                                      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 string \u2502 array&lt;struct&lt;record_id: int64, y: float64&gt;&gt;                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        40 \u2502 a      \u2502 [{'record_id': 41, 'y': 4.1}, {'record_id': 42, 'y': 4.2}] \u2502\n\u2502        50 \u2502 b      \u2502 [{'record_id': 51, 'y': 9.0}]                              \u2502\n\u2502        60 \u2502 c      \u2502 NULL                                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.LinkedTable.with_n_links","title":"mismo.LinkedTable.with_n_links","text":"<pre><code>with_n_links(*, name: str = 'n_links') -&gt; Self\n</code></pre> <p>Add a column to this table with the number of links each record has.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the new column.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'n_links'</code> </p> RETURNS DESCRIPTION <code>A new LinkedTable with the new column.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import mismo\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; left = ibis.memtable({\"record_id\": [4, 5, 6]})\n&gt;&gt;&gt; right = ibis.memtable({\"record_id\": [7, 8, 9]})\n&gt;&gt;&gt; links = ibis.memtable({\"record_id_l\": [4, 4, 5], \"record_id_r\": [7, 8, 9]})\n&gt;&gt;&gt; linkage = mismo.Linkage(left=left, right=right, links=links)\n&gt;&gt;&gt; linkage.left.with_n_links().order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 n_links \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 int64   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         4 \u2502       2 \u2502\n\u2502         5 \u2502       1 \u2502\n\u2502         6 \u2502       0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; linkage.right.with_n_links(name=\"link_count\").order_by(\"record_id\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 link_count \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 int64      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         7 \u2502          1 \u2502\n\u2502         8 \u2502          1 \u2502\n\u2502         9 \u2502          1 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.LinksTable","title":"mismo.LinksTable","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A table of links between two tables.</p> <p>This acts like an ibis table, guaranteed to have at least the columns record_id_l and record_id_r. It may have more columns, such as <code>address_match_level</code>, that describe the relationship between two records.</p> <p>In addition to the columns, this table has two properties, <code>left_</code> and <code>right_</code>, each of which is a LinkedTable object, which is a wrapper around the left and right tables respectively.</p>"},{"location":"reference/core/#mismo.LinksTable.left","title":"mismo.LinksTable.left  <code>property</code>","text":"<pre><code>left: LinkedTable\n</code></pre> <p>The left table.</p>"},{"location":"reference/core/#mismo.LinksTable.record_id_l","title":"mismo.LinksTable.record_id_l  <code>instance-attribute</code>","text":"<pre><code>record_id_l: Column\n</code></pre> <p>The record_id of the left table.</p>"},{"location":"reference/core/#mismo.LinksTable.record_id_r","title":"mismo.LinksTable.record_id_r  <code>instance-attribute</code>","text":"<pre><code>record_id_r: Column\n</code></pre> <p>The record_id of the right table.</p>"},{"location":"reference/core/#mismo.LinksTable.right","title":"mismo.LinksTable.right  <code>property</code>","text":"<pre><code>right: LinkedTable\n</code></pre> <p>The right table.</p>"},{"location":"reference/core/#mismo.LinksTable.cache","title":"mismo.LinksTable.cache","text":"<pre><code>cache() -&gt; LinksTable\n</code></pre> <p>Cache the links table.</p>"},{"location":"reference/core/#mismo.LinksTable.with_both","title":"mismo.LinksTable.with_both","text":"<pre><code>with_both() -&gt; LinksTable\n</code></pre> <p>Add all columns from <code>left</code> and <code>right</code> with suffixes <code>_l</code> and <code>_r</code></p>"},{"location":"reference/core/#mismo.LinksTable.with_left","title":"mismo.LinksTable.with_left","text":"<pre><code>with_left(\n    *values: Deferred | Callable[[Table], Value] | None,\n    **named_values: Deferred\n    | Callable[[Table], Value]\n    | None,\n) -&gt; LinksTable\n</code></pre> <p>Add columns from the left table to this table of links.</p> <p>This allows you to add specific columns from the left table, renaming or modifying them as needed, following the <code>ibis.Table</code> pattern of <code>my_table.select(\"my_col\", new_col=my_table.foo)</code>, except here we choose from the left table.</p> PARAMETER DESCRIPTION <code>values</code> <p>The columns to add from the left table. Support string names, Deferreds, etc, just like <code>ibis.Table.select</code>.</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>()</code> </p> <code>named_values</code> <p>Like values, but with names, just like <code>ibis.Table.select</code>.</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>{}</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; left = ibis.memtable({\"record_id\": [1, 2, 3], \"address\": [\"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; right = ibis.memtable({\"record_id\": [8, 9], \"address\": [\"x\", \"y\"]})\n&gt;&gt;&gt; links_raw = ibis.memtable({\"record_id_l\": [1, 3], \"record_id_r\": [8, 9]})\n&gt;&gt;&gt; links = LinksTable(links_raw, left=left, right=right)\n&gt;&gt;&gt; links.with_left(\n...     \"address\",\n...     ibis._.address.upper().name(\"address_upper\"),\n...     left_address=ibis._.address,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503 address \u2503 address_upper \u2503 left_address \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 int64       \u2502 string  \u2502 string        \u2502 string       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           1 \u2502           8 \u2502 a       \u2502 A             \u2502 a            \u2502\n\u2502           3 \u2502           9 \u2502 c       \u2502 C             \u2502 c            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.LinksTable.with_right","title":"mismo.LinksTable.with_right","text":"<pre><code>with_right(\n    *values: Deferred | Callable[[Table], Value] | None,\n    **named_values: Deferred\n    | Callable[[Table], Value]\n    | None,\n) -&gt; LinksTable\n</code></pre> <p>Add columns from the right table to this table of links.</p> <p>This allows you to add specific columns from the right table, renaming or modifying them as needed, following the <code>ibis.Table</code> pattern of <code>my_table.select(\"my_col\", new_col=my_table.foo)</code>, except here we choose from the right table.</p> PARAMETER DESCRIPTION <code>values</code> <p>The columns to add from the right table. Support string names, Deferreds, etc, just like <code>ibis.Table.select</code>.</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>()</code> </p> <code>named_values</code> <p>Like values, but with names, just like <code>ibis.Table.select</code>.</p> <p> TYPE: <code>Deferred | Callable[[Table], Value] | None</code> DEFAULT: <code>{}</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; left = ibis.memtable({\"record_id\": [1, 2, 3], \"address\": [\"a\", \"b\", \"c\"]})\n&gt;&gt;&gt; right = ibis.memtable({\"record_id\": [8, 9], \"address\": [\"x\", \"y\"]})\n&gt;&gt;&gt; links_raw = ibis.memtable({\"record_id_l\": [1, 3], \"record_id_r\": [8, 9]})\n&gt;&gt;&gt; links = LinksTable(links_raw, left=left, right=right)\n&gt;&gt;&gt; links.with_right(\n...     \"address\",\n...     ibis._.address.upper().name(\"address_upper\"),\n...     right_address=ibis._.address,\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503 address \u2503 address_upper \u2503 right_address \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 int64       \u2502 string  \u2502 string        \u2502 string        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           1 \u2502           8 \u2502 x       \u2502 X             \u2502 x             \u2502\n\u2502           3 \u2502           9 \u2502 y       \u2502 Y             \u2502 y             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.CountsTable","title":"mismo.CountsTable","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A table with at least an Integer column named <code>n</code>.</p> <p>There will also be variable number of other columns that act as identifiers.</p> <p>You won't create this directly, it will be returned to you from eg KeyLinker.key_counts_left, KeyLinker.key_counts_right, or KeyLinker.pair_counts.</p>"},{"location":"reference/core/#mismo.CountsTable.n","title":"mismo.CountsTable.n  <code>instance-attribute</code>","text":"<pre><code>n: IntegerColumn\n</code></pre> <p>The column containing the count.</p>"},{"location":"reference/core/#mismo.CountsTable.n_total","title":"mismo.CountsTable.n_total  <code>cached</code>","text":"<pre><code>n_total() -&gt; int\n</code></pre> <p>n.sum().fill_null(0), just here for convenience.</p>"},{"location":"reference/core/#mismo.UnionTable","title":"mismo.UnionTable","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A Table whose rows are the non-unique union of the rows from all sub-Tables.</p>"},{"location":"reference/core/#mismo.UnionTable.tables","title":"mismo.UnionTable.tables  <code>property</code>","text":"<pre><code>tables: tuple[Table, ...]\n</code></pre> <p>The tuple of underlying ibis Tables.</p>"},{"location":"reference/core/#mismo.UnionTable.__init__","title":"mismo.UnionTable.__init__","text":"<pre><code>__init__(tables: Iterable[Table]) -&gt; None\n</code></pre> <p>Create a UnionTable from an iterable of ibis Tables.</p>"},{"location":"reference/core/#linkers","title":"Linkers","text":"<p>Utilities and classes for the blocking phase of record linkage, where we choose pairs of records to compare.</p> <p>Without blocking, we would have to compare N*M records, which becomes intractable for datasets much larger than a few thousand.</p>"},{"location":"reference/core/#mismo.Linker","title":"mismo.Linker","text":"<p>               Bases: <code>Protocol</code></p> <p>A Protocol that takes two tables of records and produces a Linkage.</p>"},{"location":"reference/core/#mismo.Linker.__call__","title":"mismo.Linker.__call__","text":"<pre><code>__call__(left: Table, right: Table) -&gt; Linkage\n</code></pre> <p>Given two tables, return a Linkage.</p>"},{"location":"reference/core/#mismo.FullLinker","title":"mismo.FullLinker","text":"<p>               Bases: <code>Linker</code></p> <p>A Linker that yields all possible pairs.</p> <p>This will be N x M pairs for linking tasks, and N x (M-1) pairs for deduplication tasks.</p>"},{"location":"reference/core/#mismo.EmptyLinker","title":"mismo.EmptyLinker","text":"<p>               Bases: <code>Linker</code></p> <p>A Linker that yields no pairs.</p>"},{"location":"reference/core/#mismo.JoinLinker","title":"mismo.JoinLinker","text":"<p>               Bases: <code>Linker</code></p> <p>A Linker based on a join condition.</p>"},{"location":"reference/core/#mismo.JoinLinker.__call__","title":"mismo.JoinLinker.__call__","text":"<pre><code>__call__(left: Table, right: Table) -&gt; Linkage\n</code></pre> <p>Create a linkage from the join condition.</p>"},{"location":"reference/core/#mismo.JoinLinker.__init__","title":"mismo.JoinLinker.__init__","text":"<pre><code>__init__(\n    condition: Callable[[Table, Table], BooleanValue],\n    *,\n    task: Literal[\"dedupe\", \"link\"] | None = None,\n    on_slow: Literal[\"error\", \"warn\", \"ignore\"] = \"error\",\n) -&gt; None\n</code></pre> <p>Create from a join condition.</p> PARAMETER DESCRIPTION <code>condition</code> <p>The join condition.</p> <p> TYPE: <code>Callable[[Table, Table], BooleanValue]</code> </p> <code>task</code> <p>The task to perform. If <code>None</code>, the task will be inferred as \"dedupe\" if the two tables passed to call are the same, otherwise it will be inferred as \"link\".</p> <p> TYPE: <code>Literal['dedupe', 'link'] | None</code> DEFAULT: <code>None</code> </p> <code>on_slow</code> <p>What to do if the join is slow. See mismo.joins.check_join_algorithm.</p> <p> TYPE: <code>Literal['error', 'warn', 'ignore']</code> DEFAULT: <code>'error'</code> </p>"},{"location":"reference/core/#mismo.JoinLinker.__join_condition__","title":"mismo.JoinLinker.__join_condition__","text":"<pre><code>__join_condition__(\n    left: Table, right: Table\n) -&gt; BooleanValue\n</code></pre> <p>Create a join condition.</p>"},{"location":"reference/core/#mismo.KeyLinker","title":"mismo.KeyLinker","text":"<p>               Bases: <code>Linker</code></p> <p>A Linker that links records wherever they share a key, eg \"emails match.\"</p> <p>This is one of the most basic blocking rules, used very often in record linkage. This is what is used in <code>splink</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; import mismo\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; linkage = mismo.playdata.load_patents()\n&gt;&gt;&gt; t = linkage.left.select(\"record_id\", \"name\", \"latitude\")\n&gt;&gt;&gt; t.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 name                         \u2503 latitude \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 uint32    \u2502 string                       \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      2909 \u2502 * AGILENT TECHNOLOGIES, INC. \u2502     0.00 \u2502\n\u2502      3574 \u2502 * AKZO NOBEL N.V.            \u2502     0.00 \u2502\n\u2502      3575 \u2502 * AKZO NOBEL NV              \u2502     0.00 \u2502\n\u2502      3779 \u2502 * ALCATEL N.V.               \u2502    52.35 \u2502\n\u2502      3780 \u2502 * ALCATEL N.V.               \u2502    52.35 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Block the table with itself wherever the names match:</p> <pre><code>&gt;&gt;&gt; linker = mismo.KeyLinker(\"name\")\n&gt;&gt;&gt; linker(t, t).links.order_by(\n...     \"record_id_l\", \"record_id_r\"\n... ).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503 latitude_l \u2503 latitude_r \u2503 name_l         \u2503 name_r         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 int64       \u2502 float64    \u2502 float64    \u2502 string         \u2502 string         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        3779 \u2502        3780 \u2502      52.35 \u2502  52.350000 \u2502 * ALCATEL N.V. \u2502 * ALCATEL N.V. \u2502\n\u2502        3779 \u2502        3782 \u2502      52.35 \u2502   0.000000 \u2502 * ALCATEL N.V. \u2502 * ALCATEL N.V. \u2502\n\u2502        3780 \u2502        3782 \u2502      52.35 \u2502   0.000000 \u2502 * ALCATEL N.V. \u2502 * ALCATEL N.V. \u2502\n\u2502       25388 \u2502     7651559 \u2502       0.00 \u2502  50.966667 \u2502 DSM N.V.       \u2502 DSM N.V.       \u2502\n\u2502       25388 \u2502     7651560 \u2502       0.00 \u2502  52.500000 \u2502 DSM N.V.       \u2502 DSM N.V.       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Arbitrary blocking keys are supported. For example, block the table wherever</p> <ul> <li>the first 5 characters of the name in uppercase, are the same     AND</li> <li>the latitudes, rounded to 1 decimal place, are the same</li> </ul> <pre><code>&gt;&gt;&gt; linker = mismo.KeyLinker((_[\"name\"][:5].upper(), _.latitude.round(1)))\n&gt;&gt;&gt; blocker(t, t).order_by(\"record_id_l\", \"record_id_r\").head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503 latitude_l \u2503 latitude_r \u2503 name_l              \u2503 name_r              \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 int64       \u2502 float64    \u2502 float64    \u2502 string              \u2502 string              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        3574 \u2502        3575 \u2502       0.00 \u2502       0.00 \u2502 * AKZO NOBEL N.V.   \u2502 * AKZO NOBEL NV     \u2502\n\u2502        3779 \u2502        3780 \u2502      52.35 \u2502      52.35 \u2502 * ALCATEL N.V.      \u2502 * ALCATEL N.V.      \u2502\n\u2502       15041 \u2502       15042 \u2502       0.00 \u2502       0.00 \u2502 * CANON EUROPA N.V  \u2502 * CANON EUROPA N.V. \u2502\n\u2502       15041 \u2502       15043 \u2502       0.00 \u2502       0.00 \u2502 * CANON EUROPA N.V  \u2502 * CANON EUROPA NV   \u2502\n\u2502       15042 \u2502       15043 \u2502       0.00 \u2502       0.00 \u2502 * CANON EUROPA N.V. \u2502 * CANON EUROPA NV   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>We can even block on arrays! For example, first let's split each name into significant tokens:</p> <pre><code>&gt;&gt;&gt; tokens = _.name.upper().split(\" \").filter(lambda x: x.length() &gt; 4)\n&gt;&gt;&gt; t.select(tokens.name(\"tokens\"))\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 tokens                       \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array&lt;string&gt;                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['AGILENT', 'TECHNOLOGIES,'] \u2502\n\u2502 ['NOBEL']                    \u2502\n\u2502 ['NOBEL']                    \u2502\n\u2502 ['ALCATEL']                  \u2502\n\u2502 ['ALCATEL']                  \u2502\n\u2502 ['ALCATEL']                  \u2502\n\u2502 ['CANON', 'EUROPA']          \u2502\n\u2502 ['CANON', 'EUROPA']          \u2502\n\u2502 ['CANON', 'EUROPA']          \u2502\n\u2502 []                           \u2502\n\u2502 \u2026                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Now, block the tables together wherever two records share a token. Note that this blocked <code>* SCHLUMBERGER LIMITED</code> with <code>* SCHLUMBERGER TECHNOLOGY BV</code>. because they both share the <code>SCHLUMBERGER</code> token.</p> <pre><code>&gt;&gt;&gt; linker = mismo.KeyLinker(tokens.unnest())\n&gt;&gt;&gt; linker(t, t).links.filter(_.name_l != _.name_r).order_by(\n...     \"record_id_l\", \"record_id_r\"\n... ).head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503 latitude_l \u2503 latitude_r \u2503 name_l                                                     \u2503 name_r                                                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 int64       \u2502 float64    \u2502 float64    \u2502 string                                                     \u2502 string                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502        2909 \u2502    13390969 \u2502        0.0 \u2502      52.35 \u2502 * AGILENT TECHNOLOGIES, INC.                               \u2502 Hitachi Global Storage Technologies, Inc. Netherlands B.V  \u2502\n\u2502        2909 \u2502    13390970 \u2502        0.0 \u2502      52.35 \u2502 * AGILENT TECHNOLOGIES, INC.                               \u2502 Hitachi Global Storage Technologies, Inc. Netherlands B.V. \u2502\n\u2502        2909 \u2502    13391015 \u2502        0.0 \u2502      52.35 \u2502 * AGILENT TECHNOLOGIES, INC.                               \u2502 Hitachi Global Storage Technologies, Netherland B.V.       \u2502\n\u2502        2909 \u2502    13391055 \u2502        0.0 \u2502      52.50 \u2502 * AGILENT TECHNOLOGIES, INC.                               \u2502 Hitachi Global Storage Technologies, Netherlands, B.V.     \u2502\n\u2502        2909 \u2502    13391056 \u2502        0.0 \u2502      52.35 \u2502 * AGILENT TECHNOLOGIES, INC.                               \u2502 Hitachi Global Storage Technologies, Netherlands, B.V.     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#mismo.KeyLinker.__call__","title":"mismo.KeyLinker.__call__","text":"<pre><code>__call__(left: Table, right: Table) -&gt; Linkage\n</code></pre> <p>The linkage between the two tables.</p>"},{"location":"reference/core/#mismo.KeyLinker.__init__","title":"mismo.KeyLinker.__init__","text":"<pre><code>__init__(\n    keys: str\n    | Value\n    | Deferred\n    | Callable[\n        [Table, Table],\n        tuple[Value | Column, Value | Column],\n    ]\n    | Iterable[\n        str\n        | Value\n        | Deferred\n        | Callable[[Table], Value | Column | str | Deferred]\n        | tuple[\n            str\n            | Deferred\n            | Callable[\n                [Table], Value | Column | str | Deferred\n            ],\n            str\n            | Deferred\n            | Callable[\n                [Table], Value | Column | str | Deferred\n            ],\n        ]\n        | Callable[\n            [Table, Table],\n            tuple[Value | Column, Value | Column],\n        ]\n    ],\n    *,\n    max_pairs: int | None = None,\n    task: Literal[\"dedupe\", \"lookup\", \"link\"] | None = None,\n) -&gt; None\n</code></pre> <p>Create a KeyBlocker.</p> PARAMETER DESCRIPTION <code>keys</code> <p>The keys to block on. The tables will be blocked together wherever they share ALL the keys. Each key can be any of the following:</p> <ul> <li>A string, which is interpreted as the name of a column in both tables.   eg \"price\" is equivalent to <code>left.price == right.price</code></li> <li>A Deferred, which is used to reference a column in a table.   eg <code>_.price.fill_null(0)</code> is equivalent to   <code>left.price.fill_null(0) == right.price.fill_null(0)</code></li> <li>A Callable that takes a table and returns a Column.</li> <li>A 2-tuple of the above, where the first element describes the key in the   left table and the second element describes the key in the right table.   eg <code>(\"first_name\", _.GivenName.upper()\")</code> is equivalent to   <code>left.first_name == right.GivenName.upper()</code>   This is useful when the keys have different names in the two tables.</li> <li>A callable that takes the left and right tables and returns a tuple   of columns. Left and right will be joined where the columns are equal.</li> </ul> <p> TYPE: <code>str | Value | Deferred | Callable[[Table, Table], tuple[Value | Column, Value | Column]] | Iterable[str | Value | Deferred | Callable[[Table], Value | Column | str | Deferred] | tuple[str | Deferred | Callable[[Table], Value | Column | str | Deferred], str | Deferred | Callable[[Table], Value | Column | str | Deferred]] | Callable[[Table, Table], tuple[Value | Column, Value | Column]]]</code> </p> <code>max_pairs</code> <p>The maximum number of pairs to generate for each key. This is to reduce the impact of very common keys. For example, if you are linking people, the name \"John Smith\" might be very common, appearing 5000 times in both left and right. This name alone would generate 5000 * 5000 = 25 million pairs, which might be too computationally expensive. If you set <code>max_pairs=1000</code>, then any key that generates more than 1000 pairs will be ignored.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>task</code> <p>The task to count pairs for.</p> <ul> <li>\"link\": each key results in n_left * n_right pairs</li> <li>\"dedupe\": each key results in n_left * (n_right - 1) / 2 pairs    since we will only generate pair (A, B), not also (B, A).</li> <li>None: inferred from the input tables: if <code>left is right</code>, then \"dedupe\",   otherwise \"link\".</li> </ul> <p> TYPE: <code>Literal['dedupe', 'lookup', 'link'] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/core/#mismo.KeyLinker.pair_counts","title":"mismo.KeyLinker.pair_counts","text":"<pre><code>pair_counts(left: Table, right: Table) -&gt; PairCountsTable\n</code></pre> <p>Count the number of pairs that would be generated by each key.</p> <p>If you were to use this blocker to join <code>left</code> with <code>right</code>, how many pairs would be generated for each key?</p> <p>This is useful for analyzing the skew of join keys. For example, if you are joining on (surname, city), there might be only 4 values for (hoessle, tinytown), which would lead to a block of 4 * 4 = 16 record pairs.</p> <p>On the other hand, there could be 10_000 values for (smith, new york city). This would lead to 10_000 * 10_000 = 100_000_000 record pairs, which is likely too many for you to be able to compare.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left table.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>The right table.</p> <p> TYPE: <code>Table</code> </p> RETURNS DESCRIPTION <code>CountsTable</code> <p>Will have column(s) for each <code>key</code> and a column <code>n</code> with the count.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; import mismo\n&gt;&gt;&gt; records = [\n...     (1, \"a\", 1),\n...     (2, \"b\", 1),\n...     (3, \"b\", 1),\n...     (4, \"c\", 3),\n...     (5, \"b\", 2),\n...     (6, \"c\", 3),\n...     (7, None, 4),\n...     (8, \"c\", 3),\n... ]\n&gt;&gt;&gt; t = ibis.memtable(\n...     records, schema={\"record_id\": int, \"letter\": str, \"num\": int}\n... ).cache()\n&gt;&gt;&gt; t\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 letter \u2503 num   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 string \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         1 \u2502 a      \u2502     1 \u2502\n\u2502         2 \u2502 b      \u2502     1 \u2502\n\u2502         3 \u2502 b      \u2502     1 \u2502\n\u2502         4 \u2502 c      \u2502     3 \u2502\n\u2502         5 \u2502 b      \u2502     2 \u2502\n\u2502         6 \u2502 c      \u2502     3 \u2502\n\u2502         7 \u2502 NULL   \u2502     4 \u2502\n\u2502         8 \u2502 c      \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If we joined t with itself using this blocker in a dedupe task, we would end up with</p> <ul> <li>3 pairs in the (c, 3) block due to pairs (3, 6), (3, 8), and (6, 8)</li> <li>1 pairs in the (b, 1) block due to pairs (1, 2)</li> <li>0 pairs in the (a, 1) block due to record 0 not getting blocked with itself</li> <li>0 pairs in the (b, 2) block due to record 4 not getting blocked with itself</li> </ul> <pre><code>&gt;&gt;&gt; linker = mismo.KeyLinker([\"letter\", \"num\"], task=\"dedupe\")\n&gt;&gt;&gt; counts = linker.pair_counts(t, t)\n&gt;&gt;&gt; counts.order_by(\"letter\", \"num\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 letter \u2503 num   \u2503 n     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502     0 \u2502\n\u2502 b      \u2502     1 \u2502     1 \u2502\n\u2502 b      \u2502     2 \u2502     0 \u2502\n\u2502 c      \u2502     3 \u2502     3 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If we joined t with a copy of itself using this linker in a link task, we would end up with</p> <ul> <li>9 pairs in the (c, 3) block due to pairs (3,3), (3, 6), (3, 8), (6, 3), (6, 6), (6, 8), (8, 3), (8, 6), and (8, 8)</li> <li>4 pairs in the (b, 1) block due to pairs (1, 1), (1, 2), (2, 1), and (2, 2)</li> <li>1 pairs in the (a, 1) block due to pair (0, 0)</li> <li>1 pairs in the (b, 2) block due to pair (4, 4)</li> </ul> <pre><code>&gt;&gt;&gt; linker = mismo.KeyLinker([\"letter\", \"num\"], task=\"link\")\n&gt;&gt;&gt; counts = linker.pair_counts(t, t)\n&gt;&gt;&gt; counts.order_by(\"letter\", \"num\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 letter \u2503 num   \u2503 n     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 a      \u2502     1 \u2502     1 \u2502\n\u2502 b      \u2502     1 \u2502     4 \u2502\n\u2502 b      \u2502     2 \u2502     1 \u2502\n\u2502 c      \u2502     3 \u2502     9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>The returned CountsTable is a subclass of an Ibis Table with a special <code>n_total</code> method for convenience:</p> <pre><code>&gt;&gt;&gt; counts.n_total()\n15\n&gt;&gt;&gt; isinstance(counts, ibis.Table)\nTrue\n</code></pre>"},{"location":"reference/core/#mismo.KeyLinker.too_common_of_records","title":"mismo.KeyLinker.too_common_of_records","text":"<pre><code>too_common_of_records(\n    left: Table, right: Table\n) -&gt; tuple[Table, Table]\n</code></pre> <p>The prefilter clause that removes keys that would generate too many pairs.</p>"},{"location":"reference/core/#mismo.KeyLinker.key_counts_left","title":"mismo.KeyLinker.key_counts_left","text":"<pre><code>key_counts_left(left: Table) -&gt; KeyCountsTable\n</code></pre>"},{"location":"reference/core/#mismo.KeyLinker.key_counts_right","title":"mismo.KeyLinker.key_counts_right","text":"<pre><code>key_counts_right(right: Table) -&gt; KeyCountsTable\n</code></pre>"},{"location":"reference/core/#mismo.OrLinker","title":"mismo.OrLinker","text":"<p>               Bases: <code>Linker</code></p> <p>A Linker that is the logical OR of multiple [mismo.HasJoinCondition].</p> <p>Physically, this is implemented as follows: - remove any condition overlap using [mismo.joins.remove_condition_overlap] - create a LinksTable for each join condition   (which should be fast) - Union the LinksTables into a single LinksTable</p>"},{"location":"reference/core/#mismo.OrLinker.join_conditions","title":"mismo.OrLinker.join_conditions  <code>property</code>","text":"<pre><code>join_conditions: dict[str, HasJoinCondition]\n</code></pre> <p>The tuple of underling HasJoinCondition objects.</p>"},{"location":"reference/core/#mismo.linkage.sample_all_links","title":"mismo.linkage.sample_all_links","text":"<pre><code>sample_all_links(\n    left: Table,\n    right: Table,\n    *,\n    max_pairs: int | None = None,\n) -&gt; LinksTable\n</code></pre> <p>Samples up to <code>max_pairs</code> from all possible pairs of records.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left table.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>The right table.</p> <p> TYPE: <code>Table</code> </p> <code>max_pairs</code> <p>The maximum number of pairs to sample. If None, all possible pairs are sampled.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>A [LinksTable][mismo.LinksTable] with just record_id_l and record_id_r.</code> <code>All pairs will be unique.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import mismo\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; linkage = mismo.playdata.load_febrl1()\n&gt;&gt;&gt; linkage.left.head(5).select(\"record_id\", \"label_true\", \"given_name\", \"surname\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 label_true \u2503 given_name \u2503 surname  \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 uint16    \u2502 uint16     \u2502 string     \u2502 string   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         0 \u2502          0 \u2502 thomas     \u2502 rokobaro \u2502\n\u2502         1 \u2502          0 \u2502 flynn      \u2502 rokobaro \u2502\n\u2502         2 \u2502          1 \u2502 karli      \u2502 alderson \u2502\n\u2502         3 \u2502          1 \u2502 karli      \u2502 alderson \u2502\n\u2502         4 \u2502          2 \u2502 alexandra  \u2502 britten  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; mismo.linkage.sample_all_links(\n...     linkage.left, linkage.left, max_pairs=7\n... )\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 record_id_r \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 uint16      \u2502 uint16      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         427 \u2502         163 \u2502\n\u2502         511 \u2502         182 \u2502\n\u2502         767 \u2502         186 \u2502\n\u2502         665 \u2502         232 \u2502\n\u2502         340 \u2502         317 \u2502\n\u2502          14 \u2502         432 \u2502\n\u2502         323 \u2502         671 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/core/#comparing-tables","title":"Comparing tables","text":""},{"location":"reference/core/#mismo.Updates","title":"mismo.Updates","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A Table representing how individual rows were updated.</p> <p>This only represents differences in rows that exist both before and after the changes. To represent a general difference between two tables, eg with insertions and deletions, use Diff.</p> <p>This represents how each column has changed between two tables. If a column only has a 'before' field, it means this column was removed. If a column only has an 'after' field, it means this column was added. If a column has both 'before' and 'after' fields, it means this column was present in both tables.</p>"},{"location":"reference/core/#mismo.Updates.check_schemas","title":"mismo.Updates.check_schemas  <code>property</code>","text":"<pre><code>check_schemas: Literal['exactly', 'names', 'lax']\n</code></pre> <p>The schema checking mode used for this Updates object.</p>"},{"location":"reference/core/#mismo.Updates.__init__","title":"mismo.Updates.__init__","text":"<pre><code>__init__(\n    diff_table: Table,\n    /,\n    *,\n    check_schemas: Literal[\n        \"exactly\", \"names\", \"lax\"\n    ] = \"exactly\",\n) -&gt; None\n</code></pre> <p>Create an Updates object from a table of differences.</p> PARAMETER DESCRIPTION <code>diff_table</code> <p>A table with columns that are structs with at least 'before' and 'after' fields.</p> <p> TYPE: <code>Table</code> </p> <code>check_schemas</code> <p>How to check the schemas of the before and after values. - \"exactly\": both before and after must have the same columns and types. - \"names\": both before and after must have the same columns, but types can differ. - \"lax\": no schema checking, just that there is at least one of 'before' or 'after' in each column.</p> <p> TYPE: <code>Literal['exactly', 'names', 'lax']</code> DEFAULT: <code>'exactly'</code> </p>"},{"location":"reference/core/#mismo.Updates.after","title":"mismo.Updates.after","text":"<pre><code>after() -&gt; Table\n</code></pre> <p>The table after the changes.</p>"},{"location":"reference/core/#mismo.Updates.after_values","title":"mismo.Updates.after_values","text":"<pre><code>after_values() -&gt; dict[str, Column]\n</code></pre> <p>The values after the changes.</p>"},{"location":"reference/core/#mismo.Updates.apply_to","title":"mismo.Updates.apply_to","text":"<pre><code>apply_to(\n    t: Table, /, *, defaults: None | Any = NOT_SET\n) -&gt; Table\n</code></pre> <p>Return the input table with these updates applied to it.</p> PARAMETER DESCRIPTION <code>t</code> <p>The table to apply the updates to.</p> <p> TYPE: <code>Table</code> </p> <code>defaults</code> <p>If the after table has more columns than the before table, you must provide defaults. This is because there might be some rows in <code>t</code> that are not touched by this Updates. We need to know what to put in those columns for the untouched rows. This accepts anything that <code>ibis.Table.mutate()</code> accepts.</p> <p>If None, as convenience, we will use <code>null</code> as the default for all new columns. If _util.NOT_SET, an error is raised if the after table has more columns than the before table.</p> <p> TYPE: <code>None | Any</code> DEFAULT: <code>NOT_SET</code> </p>"},{"location":"reference/core/#mismo.Updates.before","title":"mismo.Updates.before","text":"<pre><code>before() -&gt; Table\n</code></pre> <p>The table before the changes.</p>"},{"location":"reference/core/#mismo.Updates.before_values","title":"mismo.Updates.before_values","text":"<pre><code>before_values() -&gt; dict[str, Column]\n</code></pre> <p>The values before the changes.</p>"},{"location":"reference/core/#mismo.Updates.from_before_after","title":"mismo.Updates.from_before_after  <code>classmethod</code>","text":"<pre><code>from_before_after(\n    before: Mapping[str, Value] | StructValue,\n    after: Mapping[str, Value] | StructValue,\n    *,\n    check_schemas: Literal[\n        \"exactly\", \"names\", \"lax\"\n    ] = \"exactly\",\n) -&gt; Updates\n</code></pre> <p>Create an Updates object from before and after values.</p> PARAMETER DESCRIPTION <code>before</code> <p>The values before the changes.</p> <p> TYPE: <code>Mapping[str, Value] | StructValue</code> </p> <code>after</code> <p>The values after the changes.</p> <p> TYPE: <code>Mapping[str, Value] | StructValue</code> </p> <code>check_schemas</code> <p>How to check the schemas of the before and after values. - \"exactly\": both before and after must have the same columns and types. - \"names\": both before and after must have the same columns, but types can differ. - \"lax\": no schema checking, just that there is at least one of 'before' or 'after' in each column.</p> <p> TYPE: <code>Literal['exactly', 'names', 'lax']</code> DEFAULT: <code>'exactly'</code> </p> RETURNS DESCRIPTION <code>Updates</code> <p>An Updates object representing the changes.</p>"},{"location":"reference/core/#mismo.Updates.from_tables","title":"mismo.Updates.from_tables  <code>classmethod</code>","text":"<pre><code>from_tables(\n    before: Table,\n    after: Table,\n    *,\n    join_on: str | Literal[False],\n    check_schemas: Literal[\n        \"exactly\", \"names\", \"lax\"\n    ] = \"exactly\",\n) -&gt; Updates\n</code></pre> <p>Create from two different tables by joining them on a key.</p> <p>Note that this results in only the rows that are present in both tables, due to the inner join on the key. Insertions and deletions should be handled separately.</p>"},{"location":"reference/core/#mismo.Diff","title":"mismo.Diff","text":"<p>A set of insertions, updates, and deletions between two tables.</p> <p>This can only semantically represent 1-1 relationships, eg a row in the <code>before</code> table corresponds to only 0 or 1 row in the <code>after</code> table, and vice versa. eg \"this row changed in these ways between these two tables\".</p> <p>To represent more general 0-N relationships, use a Linkage. eg many rows in a \"dirty\" dataset are linked to a single row in a \"clean\" dataset. Say you have a clean database of records. You just got a new batch of dirty data that might contain duplicates. Each record in the clean database might match multiple records in the dirty data. This makes it difficult to use a Diff object, because each clean record can't be paired up nicely with a single dirty record. A Linkage object is more appropriate in this case.</p> <p>This is able to represent a difference between two tables with different schemas, eg if a column is added or removed.</p>"},{"location":"reference/core/#mismo.Diff.stats","title":"mismo.Diff.stats  <code>property</code>","text":"<pre><code>stats: DiffStats\n</code></pre> <p>Statistics about this Diff.</p>"},{"location":"reference/core/#mismo.Diff.after","title":"mismo.Diff.after","text":"<pre><code>after() -&gt; Table\n</code></pre> <p>The table after the changes.</p>"},{"location":"reference/core/#mismo.Diff.before","title":"mismo.Diff.before","text":"<pre><code>before() -&gt; Table\n</code></pre> <p>The table before the changes.</p>"},{"location":"reference/core/#mismo.Diff.cache","title":"mismo.Diff.cache","text":"<pre><code>cache() -&gt; Diff\n</code></pre> <p>Return a new Diff with all tables cached.</p>"},{"location":"reference/core/#mismo.Diff.chart","title":"mismo.Diff.chart","text":"<pre><code>chart() -&gt; Chart\n</code></pre> <p>Create a chart that shows the flow of rows through the diff.</p> <p>This is just a convenience method that calls <code>self.stats.chart()</code>.</p> <pre><code>Rows\n800,000 |                                 \u2593\u2593  Inserted (50,000)\n        |                                 \u2592\u2592  Deleted (100,000)\n700,000 |                                 \u2591\u2591  Updated (200,000)\n        |                                 \u2588\u2588  Unchanged (300,000)\n600,000 |      \u2592\u2592\u2592\u2592\n        |      \u2592\u2592\u2592\u2592             \u2593\u2593\u2593\u2593\n500,000 |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n        |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n400,000 |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n        |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n300,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n200,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n100,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n      0 | Before (600,000)  After (550,000)\n</code></pre>"},{"location":"reference/core/#mismo.Diff.deletions","title":"mismo.Diff.deletions","text":"<pre><code>deletions() -&gt; Table\n</code></pre> <p>Rows that were in <code>before</code> but not in <code>after</code>.</p> <p>This has the same schema as <code>before</code>.</p>"},{"location":"reference/core/#mismo.Diff.from_before_after","title":"mismo.Diff.from_before_after  <code>classmethod</code>","text":"<pre><code>from_before_after(\n    before: Table,\n    after: Table,\n    *,\n    join_on: str | Literal[False],\n) -&gt; Self\n</code></pre> <p>Create from a before and after table.</p>"},{"location":"reference/core/#mismo.Diff.from_deltas","title":"mismo.Diff.from_deltas  <code>classmethod</code>","text":"<pre><code>from_deltas(\n    *,\n    before: Table,\n    insertions: Table | None = None,\n    updates: Updates | None = None,\n    deletions: Table | None = None,\n    updates_defaults: None | Any = NOT_SET,\n) -&gt; Self\n</code></pre> <p>Create from a starting point and a set of transformations.</p> PARAMETER DESCRIPTION <code>before</code> <p>The table before the changes.</p> <p> TYPE: <code>Table</code> </p> <code>insertions</code> <p>Rows that were in <code>after</code> but not in <code>before</code>. If None, we assume there are no insertions.</p> <p> TYPE: <code>Table | None</code> DEFAULT: <code>None</code> </p> <code>updates</code> <p>Rows that were changed between <code>before</code> and <code>after</code>. If None, we assume there are no updates.</p> <p> TYPE: <code>Updates | None</code> DEFAULT: <code>None</code> </p> <code>deletions</code> <p>Rows that were in <code>before</code> but not in <code>after</code>. If None, we assume there are no deletions.</p> <p> TYPE: <code>Table | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Diff</code>"},{"location":"reference/core/#mismo.Diff.from_parquets","title":"mismo.Diff.from_parquets  <code>classmethod</code>","text":"<pre><code>from_parquets(\n    directory: str | Path,\n    /,\n    *,\n    backend: BaseBackend | None = None,\n) -&gt; Self\n</code></pre> <p>Create a Diff by reading parquets from the given directory.</p>"},{"location":"reference/core/#mismo.Diff.insertions","title":"mismo.Diff.insertions","text":"<pre><code>insertions() -&gt; Table\n</code></pre> <p>Rows that were in <code>after</code> but not in <code>before</code>.</p> <p>This has the same schema as <code>after</code>.</p>"},{"location":"reference/core/#mismo.Diff.to_parquets","title":"mismo.Diff.to_parquets","text":"<pre><code>to_parquets(\n    directory: str | Path, /, *, overwrite: bool = False\n) -&gt; None\n</code></pre> <p>Write the tables in the changes to parquet files.</p>"},{"location":"reference/core/#mismo.Diff.unchanged","title":"mismo.Diff.unchanged","text":"<pre><code>unchanged() -&gt; Table\n</code></pre> <p>Rows that were unchanged between <code>before</code> and <code>after</code>.</p>"},{"location":"reference/core/#mismo.Diff.updates","title":"mismo.Diff.updates","text":"<pre><code>updates() -&gt; Updates\n</code></pre> <p>Rows that were changed between <code>before</code> and <code>after</code>.</p> <p><code>self.updates().before()</code> and <code>self.updates().after()</code> have the same schemas as <code>before</code> and <code>after</code>, respectively.</p>"},{"location":"reference/core/#mismo.DiffStats","title":"mismo.DiffStats","text":"<p>Summary statistics about a Diff, such as number of insertions, deletions, etc.</p>"},{"location":"reference/core/#mismo.DiffStats.__init__","title":"mismo.DiffStats.__init__","text":"<pre><code>__init__(diff: Diff) -&gt; None\n</code></pre> <p>Create from a Diff.</p>"},{"location":"reference/core/#mismo.DiffStats.chart","title":"mismo.DiffStats.chart","text":"<pre><code>chart() -&gt; Chart\n</code></pre> <p>Create a chart that shows the flow of rows through the diff.</p> <pre><code>Rows\n800,000 |                                 \u2593\u2593  Inserted (50,000)\n        |                                 \u2592\u2592  Deleted (100,000)\n700,000 |                                 \u2591\u2591  Updated (200,000)\n        |                                 \u2588\u2588  Unchanged (300,000)\n600,000 |      \u2592\u2592\u2592\u2592\n        |      \u2592\u2592\u2592\u2592             \u2593\u2593\u2593\u2593\n500,000 |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n        |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n400,000 |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n        |      \u2591\u2591\u2591\u2591             \u2591\u2591\u2591\u2591\n300,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n200,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n100,000 |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n        |      \u2588\u2588\u2588\u2588             \u2588\u2588\u2588\u2588\n      0 | Before (600,000)  After (550,000)\n</code></pre>"},{"location":"reference/core/#mismo.DiffStats.n_after","title":"mismo.DiffStats.n_after  <code>cached</code>","text":"<pre><code>n_after() -&gt; int\n</code></pre> <p>Number of rows in <code>after</code>.</p>"},{"location":"reference/core/#mismo.DiffStats.n_before","title":"mismo.DiffStats.n_before  <code>cached</code>","text":"<pre><code>n_before() -&gt; int\n</code></pre> <p>Number of rows in <code>before</code>.</p>"},{"location":"reference/core/#mismo.DiffStats.n_deletions","title":"mismo.DiffStats.n_deletions  <code>cached</code>","text":"<pre><code>n_deletions() -&gt; int\n</code></pre> <p>Number of rows that were in <code>before</code> but not in <code>after</code>.</p>"},{"location":"reference/core/#mismo.DiffStats.n_insertions","title":"mismo.DiffStats.n_insertions  <code>cached</code>","text":"<pre><code>n_insertions() -&gt; int\n</code></pre> <p>Number of rows that were in <code>after</code> but not in <code>before</code>.</p>"},{"location":"reference/core/#mismo.DiffStats.n_unchanged","title":"mismo.DiffStats.n_unchanged  <code>cached</code>","text":"<pre><code>n_unchanged() -&gt; int\n</code></pre> <p>Number of rows that were unchanged between <code>before</code> and <code>after</code>.</p>"},{"location":"reference/core/#mismo.DiffStats.n_updates","title":"mismo.DiffStats.n_updates  <code>cached</code>","text":"<pre><code>n_updates() -&gt; int\n</code></pre> <p>Number of rows that were changed between <code>before</code> and <code>after</code>.</p>"},{"location":"reference/core/#mismo.LinkCountsTable","title":"mismo.LinkCountsTable","text":"<p>               Bases: <code>TableWrapper</code></p> <p>A table representing the number of records binned by number of links.</p> <p>eg \"There were 700 records with 0 links, 300 with 1 link, 20 with 2 links, ...\"</p>"},{"location":"reference/core/#mismo.LinkCountsTable.n_links","title":"mismo.LinkCountsTable.n_links  <code>instance-attribute</code>","text":"<pre><code>n_links: IntegerColumn\n</code></pre> <p>The number of links.</p>"},{"location":"reference/core/#mismo.LinkCountsTable.n_records","title":"mismo.LinkCountsTable.n_records  <code>instance-attribute</code>","text":"<pre><code>n_records: IntegerColumn\n</code></pre> <p>The number of records.</p>"},{"location":"reference/core/#mismo.LinkCountsTable.__init__","title":"mismo.LinkCountsTable.__init__","text":"<pre><code>__init__(t: Table) -&gt; None\n</code></pre> <p>Create from an ibis table with exactly columns 'n_records' and 'n_links'.</p> PARAMETER DESCRIPTION <code>t</code> <p>The table with exactly columns 'n_records' and 'n_links'.</p> <p> TYPE: <code>Table</code> </p>"},{"location":"reference/core/#mismo.LinkCountsTable.chart","title":"mismo.LinkCountsTable.chart","text":"<pre><code>chart() -&gt; Chart\n</code></pre> <p>A bar chart of the number of records by the number of links.</p> <pre><code>                 Number of Records\nNumber of          By Link Count\n  Records\n        |    \u2588\n100,000 | \u2588  \u2588\n        | \u2588  \u2588\n        | \u2588  \u2588  \u2588\n 10,000 | \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588\n  1,000 | \u2588  \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588\n        | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588\n    100 | \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588  \u2588\n        | 0  1  2  3  4 10 12 14 23\n        Number of Links\n</code></pre>"},{"location":"reference/datasets/","title":"Datasets","text":""},{"location":"reference/datasets/#mismo.Datasets","title":"mismo.Datasets","text":"<p>An ordered, dict-like collection of tables of records.</p> <p>All tables must have a column named 'record_id' that is globally unique. The dtype of the 'record_id' column must be the same in all tables. Besides that, the schema of the tables can be different.</p> <p>This is a nice abstraction over the fact that some record linkage problems are deduplication, and thus involve only one table, while others are linkage, and involve two tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.names","title":"mismo.Datasets.names  <code>property</code>","text":"<pre><code>names: tuple[str, ...]\n</code></pre> <p>The names of the underlying tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.shared_schema","title":"mismo.Datasets.shared_schema  <code>property</code>","text":"<pre><code>shared_schema: Schema\n</code></pre> <p>The schema that all tables have in common.</p> <p>Columns with conflicting types are omitted.</p> <p>This is useful for operations that require the same schema in all tables, for example getting all the record_ids.</p>"},{"location":"reference/datasets/#mismo.Datasets.tables","title":"mismo.Datasets.tables  <code>property</code>","text":"<pre><code>tables: tuple[Table, ...]\n</code></pre> <p>The underlying tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.__contains__","title":"mismo.Datasets.__contains__","text":"<pre><code>__contains__(key: str | Table) -&gt; bool\n</code></pre> <p>Check if a table is in the collection by name or value.</p>"},{"location":"reference/datasets/#mismo.Datasets.__getitem__","title":"mismo.Datasets.__getitem__","text":"<pre><code>__getitem__(key: str | int) -&gt; Table\n</code></pre> <p>Get a table by name or index.</p>"},{"location":"reference/datasets/#mismo.Datasets.__init__","title":"mismo.Datasets.__init__","text":"<pre><code>__init__(\n    tables: Table | Iterable[Table] | Mapping[str, Table],\n) -&gt; None\n</code></pre> <p>Create a new Datasets.</p> <p>If <code>tables</code> is Mapping, then it is used as-is. If <code>tables</code> is a single table, it is named \"dataset_0\". If <code>tables</code> is an iterable of tables, then we try to find their names by: - calling <code>get_name()</code> on each table. If that fails, then fall back to... - using \"left\" and \"right\" for two tables - using \"dataset_i\" otherwise</p>"},{"location":"reference/datasets/#mismo.Datasets.__iter__","title":"mismo.Datasets.__iter__","text":"<pre><code>__iter__() -&gt; Iterable[Table]\n</code></pre> <p>Iterate over the tables in the order they were added.</p>"},{"location":"reference/datasets/#mismo.Datasets.__len__","title":"mismo.Datasets.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.all_record_ids","title":"mismo.Datasets.all_record_ids","text":"<pre><code>all_record_ids() -&gt; Column\n</code></pre> <p>Return all unique record_ids from all tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.cache","title":"mismo.Datasets.cache","text":"<pre><code>cache() -&gt; Datasets\n</code></pre> <p>Return a new Datasets with all tables cached.</p>"},{"location":"reference/datasets/#mismo.Datasets.filter","title":"mismo.Datasets.filter","text":"<pre><code>filter(\n    f: Deferred | Callable[[str, Table], Table],\n) -&gt; Table\n</code></pre> <p>Return a new Datasets with all tables filtered by <code>f</code>.</p>"},{"location":"reference/datasets/#mismo.Datasets.items","title":"mismo.Datasets.items","text":"<pre><code>items() -&gt; Iterable[tuple[str, Table]]\n</code></pre> <p>The names and tables of the underlying tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.keys","title":"mismo.Datasets.keys","text":"<pre><code>keys() -&gt; Iterable[str]\n</code></pre> <p>The names of the underlying tables.</p>"},{"location":"reference/datasets/#mismo.Datasets.map","title":"mismo.Datasets.map","text":"<pre><code>map(f: Deferred | Callable[[str, Table], Table]) -&gt; Table\n</code></pre> <p>Return a new Datasets with all tables transformed by <code>f</code>.</p>"},{"location":"reference/datasets/#mismo.Datasets.unioned","title":"mismo.Datasets.unioned","text":"<pre><code>unioned() -&gt; Table\n</code></pre> <p>Select the <code>self.shared_schema</code> columns from all tables and union them.</p>"},{"location":"reference/datasets/#mismo.Datasets.values","title":"mismo.Datasets.values","text":"<pre><code>values() -&gt; Iterable[Table]\n</code></pre> <p>The underlying tables.</p>"},{"location":"reference/eda/","title":"EDA API","text":"<p>This module contains utilities for cleaning and preparing data for linkage.</p>"},{"location":"reference/eda/#mismo.eda.distribution_chart","title":"mismo.eda.distribution_chart","text":"<pre><code>distribution_chart(\n    vals: Column, *, limit: int | None = None\n) -&gt; Chart\n</code></pre> <p>Make a Altair histogram of values.</p> <p>Useful as an exploratory tool to look at what values are present in a column.</p> PARAMETER DESCRIPTION <code>vals</code> <p>The values to plot.</p> <p> TYPE: <code>ColumnExpr</code> </p> <code>limit</code> <p>The maximum number of bars to plot, by default 1000</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Chart</code> <p>The histogram.</p>"},{"location":"reference/eda/#mismo.eda.distribution_dashboard","title":"mismo.eda.distribution_dashboard","text":"<pre><code>distribution_dashboard(\n    records: Table,\n    *,\n    column: str | None = None,\n    limit: int | None = None,\n) -&gt; VBox\n</code></pre> <p>Make an ipywidget dashboard for exploring the distribution of values in a table.</p> PARAMETER DESCRIPTION <code>records</code> <p>The table to plot.</p> <p> TYPE: <code>Table</code> </p> <code>column</code> <p>The initial column to plot. If None, the first column is used. You can change this interactively in the returned dashboard.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>limit</code> <p>The initial maximum number of values to plot, by default 100. You can change this interactively in the returned dashboard.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>VBox</code> <p>The dashboard.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#mismo.exceptions","title":"mismo.exceptions","text":""},{"location":"reference/exceptions/#mismo.exceptions.MismoError","title":"mismo.exceptions.MismoError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all Mismo errors.</p>"},{"location":"reference/exceptions/#mismo.exceptions.MismoWarning","title":"mismo.exceptions.MismoWarning","text":"<p>               Bases: <code>Warning</code></p> <p>Base class for all Mismo warnings.</p>"},{"location":"reference/exceptions/#mismo.exceptions.SlowJoinError","title":"mismo.exceptions.SlowJoinError","text":"<p>               Bases: <code>SlowJoinMixin</code>, <code>ValueError</code>, <code>MismoError</code></p> <p>Error for slow join algorithms.</p>"},{"location":"reference/exceptions/#mismo.exceptions.SlowJoinMixin","title":"mismo.exceptions.SlowJoinMixin","text":""},{"location":"reference/exceptions/#mismo.exceptions.SlowJoinMixin.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm: SlowJoinAlgorithm = algorithm\n</code></pre> <p>The algorithm used for the join, eg 'NESTED_LOOP_JOIN'.</p>"},{"location":"reference/exceptions/#mismo.exceptions.SlowJoinMixin.condition","title":"condition  <code>instance-attribute</code>","text":"<pre><code>condition: BooleanValue = condition\n</code></pre> <p>The join condition that is slow.</p>"},{"location":"reference/exceptions/#mismo.exceptions.SlowJoinWarning","title":"mismo.exceptions.SlowJoinWarning","text":"<p>               Bases: <code>SlowJoinMixin</code>, <code>UserWarning</code>, <code>MismoWarning</code></p> <p>Warning for slow join algorithms.</p>"},{"location":"reference/exceptions/#mismo.exceptions.UnsupportedBackendError","title":"mismo.exceptions.UnsupportedBackendError","text":"<p>               Bases: <code>ValueError</code>, <code>MismoError</code></p> <p>An operation is not supported by a particular backend.</p>"},{"location":"reference/fs/","title":"Fellegi-Sunter Model","text":"<p>See the Fellegi-Sunter Concept guide for background info.</p>"},{"location":"reference/fs/#mismo.fs.Weights","title":"mismo.fs.Weights","text":"<p>Weights for the Fellegi-Sunter model.</p> <p>An unordered, dict-like collection of ComparerWeights, one for each LevelComparer of the same name.</p>"},{"location":"reference/fs/#mismo.fs.Weights.__getitem__","title":"mismo.fs.Weights.__getitem__","text":"<pre><code>__getitem__(name: str) -&gt; ComparerWeights\n</code></pre> <p>Get a <code>ComparerWeights</code> by name.</p>"},{"location":"reference/fs/#mismo.fs.Weights.__init__","title":"mismo.fs.Weights.__init__","text":"<pre><code>__init__(comparer_weights: Iterable[ComparerWeights])\n</code></pre> <p>Create a new Weights object.</p>"},{"location":"reference/fs/#mismo.fs.Weights.__iter__","title":"mismo.fs.Weights.__iter__","text":"<pre><code>__iter__() -&gt; Iterator[ComparerWeights]\n</code></pre> <p>Iterate over the contained <code>ComparerWeights</code>.</p>"},{"location":"reference/fs/#mismo.fs.Weights.__len__","title":"mismo.fs.Weights.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of <code>ComparerWeights</code>.</p>"},{"location":"reference/fs/#mismo.fs.Weights.compare_and_score","title":"mismo.fs.Weights.compare_and_score","text":"<pre><code>compare_and_score(\n    t: Table, level_comparers: Iterable[LevelComparer]\n) -&gt; Table\n</code></pre> <p>Compare and score record pairs.</p> <p>Use the given <code>level_comparers</code> to label the record pairs, and then score the results using <code>self.score_compared</code>.</p>"},{"location":"reference/fs/#mismo.fs.Weights.from_json","title":"mismo.fs.Weights.from_json  <code>classmethod</code>","text":"<pre><code>from_json(json: dict | str | Path) -&gt; Self\n</code></pre> <p>Create a Weights object from a JSON-serializable representation.</p> PARAMETER DESCRIPTION <code>json</code> <p>If a dict, assumed to be the JSON-serializable representation. Load it directly. If a str or Path, assumed to be a path to a JSON file. Load it from that file.</p> <p> TYPE: <code>dict | str | Path</code> </p> RETURNS DESCRIPTION <code>Weights</code> <p>The Weights object created from the JSON-serializable representation.</p>"},{"location":"reference/fs/#mismo.fs.Weights.plot","title":"mismo.fs.Weights.plot","text":"<pre><code>plot() -&gt; Chart\n</code></pre> <p>Plot the weights for all of the LevelComparers.</p>"},{"location":"reference/fs/#mismo.fs.Weights.score_compared","title":"mismo.fs.Weights.score_compared","text":"<pre><code>score_compared(compared: Table) -&gt; Table\n</code></pre> <p>Score already-compared record pairs.</p> <p>This assumes that there is already a column one for each LevelComparer that contains the labels for each record pair. For example, if we have a LevelComparer called \"address\", then we should have a column called \"address\" that contains labels like \"exact\", \"one-letter-off\", \"same-city\", etc.</p> <p>For each LevelComparer, we add a column, <code>{comparer.name}_odds</code>. This is a number that describes how this comparer affects the likelihood of a match. For example, an odds of 10 means that this comparer increased the likelihood of a match by 10x as compared to if we hadn't looked at this comparer. For example, the column might be called \"name_odds\" and have values like 10, 0.1, 1.</p> <p>In addition to these per-LevelComparer columns, we also add a column called \"odds\" which is the overall odds for each record pair. We calculate this by starting with the odds of 1 and then multiplying by each LevelComparer's odds to get the overall odds.</p>"},{"location":"reference/fs/#mismo.fs.Weights.to_json","title":"mismo.fs.Weights.to_json","text":"<pre><code>to_json(path: str | Path | None = None) -&gt; dict\n</code></pre> <p>Return a JSON-serializable representation of the weights.</p> <p>If <code>path</code> is given, write the dict to the file at that path in addition to returning it.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights","title":"mismo.fs.ComparerWeights","text":"<p>The weights for a single LevelComparer.</p> <p>An ordered, dict-like collection of LevelWeights one for each level.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.name","title":"mismo.fs.ComparerWeights.name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the LevelComparer these weights are for, eg 'name\" or \"address\".</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.__contains__","title":"mismo.fs.ComparerWeights.__contains__","text":"<pre><code>__contains__(name_or_index: str | int) -&gt; bool\n</code></pre> <p>Check if a LevelWeights is present by name or index.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.__getitem__","title":"mismo.fs.ComparerWeights.__getitem__","text":"<pre><code>__getitem__(name_or_index: str | int) -&gt; LevelWeights\n</code></pre><pre><code>__getitem__(\n    name_or_index: slice,\n) -&gt; tuple[LevelWeights, ...]\n</code></pre> <pre><code>__getitem__(\n    name_or_index: str | int | slice,\n) -&gt; LevelWeights | tuple[LevelWeights, ...]\n</code></pre> <p>Get a LevelWeights by name or index.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.__init__","title":"mismo.fs.ComparerWeights.__init__","text":"<pre><code>__init__(name: str, level_weights: Iterable[LevelWeights])\n</code></pre> <p>Create a new ComparerWeights object.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.__iter__","title":"mismo.fs.ComparerWeights.__iter__","text":"<pre><code>__iter__() -&gt; Iterator[LevelWeights]\n</code></pre> <p>Iterate over the LevelWeights, including the implicit ELSE level.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.__len__","title":"mismo.fs.ComparerWeights.__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The number of LevelWeights, including the implicit ELSE level.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.log_odds","title":"mismo.fs.ComparerWeights.log_odds","text":"<pre><code>log_odds(labels: str | int) -&gt; float\n</code></pre><pre><code>log_odds(\n    labels: StringValue | IntegerValue,\n) -&gt; FloatingValue\n</code></pre> <pre><code>log_odds(\n    labels: str | int | StringValue | IntegerValue,\n) -&gt; float | FloatingValue\n</code></pre> <p>Calculate the log odds for each record pair.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.match_probability","title":"mismo.fs.ComparerWeights.match_probability","text":"<pre><code>match_probability(labels: str | int) -&gt; float\n</code></pre><pre><code>match_probability(\n    labels: StringValue | IntegerValue,\n) -&gt; FloatingValue\n</code></pre> <pre><code>match_probability(\n    labels: str | int | StringValue | IntegerValue,\n) -&gt; float | FloatingValue\n</code></pre> <p>Calculate the match probability for each record pair.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.odds","title":"mismo.fs.ComparerWeights.odds","text":"<pre><code>odds(labels: str | int) -&gt; float\n</code></pre><pre><code>odds(labels: StringValue | IntegerValue) -&gt; FloatingValue\n</code></pre> <pre><code>odds(\n    labels: str | int | StringValue | IntegerValue,\n) -&gt; float | FloatingValue\n</code></pre> <p>Calculate the odds for each record pair.</p> <p>If <code>labels</code> is a string or integer, then we calculate the odds for that level. For example, if <code>labels</code> is \"close\", then we calculate the odds for the \"close\" level. If <code>labels</code> is 0, then we calculate the odds for the first level. If <code>labels</code> is -1, then we calculate the odds for the last level (the ELSE level).</p> <p>If <code>labels</code> is a StringValue or IntegerValue, then we do the same thing, except that we return an ibis FloatingValue instead of a python float.</p>"},{"location":"reference/fs/#mismo.fs.ComparerWeights.plot","title":"mismo.fs.ComparerWeights.plot  <code>staticmethod</code>","text":"<pre><code>plot() -&gt; Chart\n</code></pre> <p>Plot the weights for this Comparer.</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights","title":"mismo.fs.LevelWeights","text":"<p>Weights for a single MatchLevel.</p> <p>This describes for example \"If zipcodes match perfectly, then this increases the probability of a match by 10x as compared to if we hadn't looked at zipcode\".</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights.log_odds","title":"mismo.fs.LevelWeights.log_odds  <code>property</code>","text":"<pre><code>log_odds: float\n</code></pre> <p>The log base 10 of the odds.</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights.m","title":"mismo.fs.LevelWeights.m  <code>property</code>","text":"<pre><code>m: float\n</code></pre> <p>Among true-matches, what proportion of them have this level?</p> <p>1 means this level is a good indication of a match, 0 means it's a good indication of a non-match.</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights.name","title":"mismo.fs.LevelWeights.name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the level, e.g. \"Exact Match\".</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights.odds","title":"mismo.fs.LevelWeights.odds  <code>property</code>","text":"<pre><code>odds: float\n</code></pre> <p>How much more likely is a match than a non-match at this level?</p> <p>This is derived from m and u. This is the same thing as \"Bayes Factor\" in splink.</p> <ul> <li>values below 1 is evidence against a match</li> <li>values above 1 is evidence for a match</li> <li>1 means this level does not provide any evidence for or against a match</li> </ul>"},{"location":"reference/fs/#mismo.fs.LevelWeights.u","title":"mismo.fs.LevelWeights.u  <code>property</code>","text":"<pre><code>u: float\n</code></pre> <p>Among non-matches, what proportion of them have this level?</p> <p>1 means this level is a good indication of a non-match, 0 means it's a good indication of a match.</p>"},{"location":"reference/fs/#mismo.fs.LevelWeights.__init__","title":"mismo.fs.LevelWeights.__init__","text":"<pre><code>__init__(name: str, *, m: float, u: float) -&gt; None\n</code></pre> <p>Create a new LevelWeights object.</p>"},{"location":"reference/fs/#mismo.fs.train_using_labels","title":"mismo.fs.train_using_labels","text":"<pre><code>train_using_labels(\n    comparers: Iterable[LevelComparer],\n    left: Table,\n    right: Table,\n    *,\n    max_pairs: int = 1000000000,\n) -&gt; Weights\n</code></pre> <p>Estimate all Weights for a set of LevelComparers using labeled records.</p> <p>The m parameters represent the proportion of record pairs that fall into each MatchLevel amongst truly matching pairs. This function estimates the m parameters using the <code>label_true</code> columns in the input datasets.</p> <p>The u parameters represent the proportion of record pairs that fall into each MatchLevel amongst truly non-matching records. This function estimates the u parameters using random sampling.</p> PARAMETER DESCRIPTION <code>comparers</code> <p>The comparers to train.</p> <p> TYPE: <code>Iterable[LevelComparer]</code> </p> <code>left</code> <p>The left dataset.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>The right dataset.</p> <p> TYPE: <code>Table</code> </p> <code>max_pairs</code> <p>The maximum number of pairs to sample. This is used for both the m and u estimates.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000000000</code> </p> RETURNS DESCRIPTION <code>Weights</code> <p>The estimated weights for each comparer.</p>"},{"location":"reference/fs/#mismo.fs.train_using_em","title":"mismo.fs.train_using_em","text":"<pre><code>train_using_em(\n    comparers: Iterable[LevelComparer],\n    left: Table,\n    right: Table,\n    *,\n    max_pairs: int | None = None,\n) -&gt; Weights\n</code></pre> <p>Train weights on unlabeled data using an expectation maximization algorithm.</p> PARAMETER DESCRIPTION <code>comparers</code> <p>The comparers to train.</p> <p> TYPE: <code>Iterable[LevelComparer]</code> </p> <code>left</code> <p>The left dataset.</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>The right dataset.</p> <p> TYPE: <code>Table</code> </p> <code>max_pairs</code> <p>The maximum number of pairs to sample. If None, all pairs are used.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Weights</code> <p>The estimated weights for each comparer.</p>"},{"location":"reference/fs/#mismo.fs.plot_weights","title":"mismo.fs.plot_weights","text":"<pre><code>plot_weights(\n    weights: ComparerWeights | Iterable[ComparerWeights],\n) -&gt; Chart\n</code></pre> <p>Plot the weights for Comparer(s).</p> <p>Use this to - See which levels are common and which are rare.   If all pairs are getting matched by only one level, you probably   want to adjust the conditions so that pairs are more evenly distributed.   For example, if you have an \"exact match\" level that hardly is ever used,   that could be an indication that your condition is too strict and you should   relax it. - See the odds for each level.   If the odds for a \"exact match\" level are lower than you expect, perhaps   near 1, that could be an indication that your condition is too loose and   there are many non-matches sneaking into that level. You should inspect   those pairs and figure out how to tighted the condition so   that only matches are in that level.</p> PARAMETER DESCRIPTION <code>weights</code> <p>The weights to plot.</p> <p> TYPE: <code>ComparerWeights | Iterable[ComparerWeights]</code> </p> RETURNS DESCRIPTION <code>Chart</code> <p>The plot.</p>"},{"location":"reference/join/","title":"Joining","text":""},{"location":"reference/join/#join-utilities","title":"Join Utilities","text":""},{"location":"reference/join/#mismo.HasJoinCondition","title":"mismo.HasJoinCondition","text":"<p>               Bases: <code>Protocol</code></p> <p>Has <code>__join_condition__(left: ibis.Table, right: ibis.Table)</code>, which returns something that <code>ibis.join()</code> understands.</p> <p>There are concrete implementations of this for various types of join conditions. For example, <code>BooleanJoinCondition</code> wraps a boolean or an <code>ibis.ir.BooleanValue</code> expression.</p>"},{"location":"reference/join/#mismo.HasJoinCondition.__join_condition__","title":"mismo.HasJoinCondition.__join_condition__","text":"<pre><code>__join_condition__(\n    left: Table, right: Table\n) -&gt; BooleanValue | bool\n</code></pre> <p>Given a left and right table, return something that <code>ibis.join()</code> understands.</p>"},{"location":"reference/join/#mismo.join_condition","title":"mismo.join_condition","text":"<pre><code>join_condition(\n    obj: IntoHasJoinCondition,\n) -&gt; HasJoinCondition\n</code></pre> <p>Create a HasJoinCondition from an object.</p> PARAMETER DESCRIPTION <code>obj</code> <p>The object to create a join condition from. This can be anything that ibis understands as join condition, such as a boolean, an ibis.ir.BooleanValue expression, a <code>str</code>, an ibis.Deferred, etc. It also supports other types, such as <code>lambda left, right: &lt;one of the above&gt;</code>,</p> <p> TYPE: <code>IntoHasJoinCondition</code> </p> RETURNS DESCRIPTION <code>    An object that follows the [HasJoinCondition][mismo.HasJoinCondition] protocol.</code>"},{"location":"reference/join/#mismo.IntoHasJoinCondition","title":"mismo.IntoHasJoinCondition  <code>module-attribute</code>","text":"<pre><code>IntoHasJoinCondition: TypeAlias = Union[\n    HasJoinCondition,\n    bool,\n    BooleanValue,\n    str,\n    Deferred,\n    Callable[\n        [Table, Table],\n        HasJoinCondition | bool | BooleanValue,\n    ],\n    Iterable[\n        HasJoinCondition,\n        bool,\n        BooleanValue,\n        str,\n        Deferred,\n        Callable[\n            [Table, Table],\n            HasJoinCondition | bool | BooleanValue,\n        ],\n    ],\n]\n</code></pre> <p>An object that can be converted into a HasJoinCondition with mismo.join_condition()</p>"},{"location":"reference/join/#mismo.join","title":"mismo.join","text":"<pre><code>join(\n    left: Table,\n    right: Table,\n    predicates: IntoHasJoinCondition = (),\n    how: str = \"inner\",\n    *,\n    lname: str = \"{name}\",\n    rname: str = \"{name}_right\",\n    rename_all: bool = False,\n)\n</code></pre> <p>Ibis.join, but with enhanced condition resolution.</p> <p>This is a wrapper around <code>ibis.join</code> that</p> <ul> <li>Allows for slightly more flexible join conditions.</li> <li>Adds an option for renaming all columns with <code>lname</code> and <code>rname</code>,   not just those that collide (the default behavior).</li> </ul> PARAMETER DESCRIPTION <code>left</code> <p>The left table to block</p> <p> TYPE: <code>Table</code> </p> <code>right</code> <p>The right table to block</p> <p> TYPE: <code>Table</code> </p> <code>predicates</code> <p>What <code>ibis.join()</code> accepts as a predicate, plus some extras.</p> <p>Anything that <code>ibis.join()</code> accepts as a predicate: - An <code>ibis.BooleanValue</code>, such as <code>left.last_name == right.surname.upper()</code>. - A string, which is interpreted as the name of a column in both tables.   eg \"price\" is equivalent to <code>left.price == right.price</code>. - A Deferred, which is used to reference a column in a table   eg \"_.price.fill_null(0)\" is equivalent to <code>left.price.fill_null(0) == right.price.fill_null(0)</code></p> <p>Plus some extra sorts of inputs: - A 2-tuple tuple of one of the above.   The first element is for the left table, the second is for the right table.   This is useful when the column names are different in the two tables,   or require some transformation/normalization.   For example <code>(\"last_name\", _.surname.upper()\")</code> is equivalent to   <code>left.last_name == right.surname.upper()</code> - A Callable of signature (left: Table, right: Table, args) -&gt; one of the above</p> <p> TYPE: <code>IntoHasJoinCondition</code> DEFAULT: <code>()</code> </p> <code>how</code> <p>Behaves the the same as in <code>ibis.join()</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'inner'</code> </p> <code>lname</code> <p>Behaves the the same as in <code>ibis.join()</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'{name}'</code> </p> <code>rname</code> <p>Behaves the the same as in <code>ibis.join()</code></p> <p> TYPE: <code>str</code> DEFAULT: <code>'{name}_right'</code> </p> <code>rename_all</code> <p>Should we apply <code>lname</code> and <code>rname</code> to ALL columns in the output, or just on the ones that collide between the two tables (the default, the same as in <code>ibis.join()</code>)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"reference/join/#mismo.left","title":"mismo.left  <code>module-attribute</code>","text":"<pre><code>left = var('left')\n</code></pre> <p>A deferred placeholder for the left table in a join.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; condition = mismo.left.last_name.upper() == mismo.right.family_name.upper()\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; my_left_table = ibis.memtable([(\"johnson\",), (\"smith\",)], columns=[\"last_name\"])\n&gt;&gt;&gt; my_right_table = ibis.memtable([(\"JOHNSON\",), (\"JONES\",)], columns=[\"family_name\"])\n&gt;&gt;&gt; mismo.join(my_left_table, my_right_table, condition)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 last_name \u2503 family_name \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 johnson   \u2502 JOHNSON     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/join/#mismo.right","title":"mismo.right  <code>module-attribute</code>","text":"<pre><code>right = var('right')\n</code></pre> <p>A deferred placeholder for the right table in a join.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; condition = mismo.left.last_name.upper() == mismo.right.family_name.upper()\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; my_left_table = ibis.memtable([(\"johnson\",), (\"smith\",)], columns=[\"last_name\"])\n&gt;&gt;&gt; my_right_table = ibis.memtable([(\"JOHNSON\",), (\"JONES\",)], columns=[\"family_name\"])\n&gt;&gt;&gt; mismo.join(my_left_table, my_right_table, condition)\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 last_name \u2503 family_name \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string    \u2502 string      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 johnson   \u2502 JOHNSON     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/join/#analyze-join-algorithm","title":"Analyze: Join Algorithm","text":"<p>Analyze the actual algorithm that the SQL engine will use when pairing up records during the join. In particular, check for slow <code>O(n*m)</code> nested loop joins.</p> <p>See https://duckdb.org/2022/05/27/iejoin.html for a very good explanation of how SQL engines (or at least duckdb) chooses a join algorithm.</p>"},{"location":"reference/join/#mismo.joins.get_join_algorithm","title":"mismo.joins.get_join_algorithm","text":"<pre><code>get_join_algorithm(\n    left: Table, right: Table, condition\n) -&gt; str\n</code></pre> <p>Return one of the JOIN_ALGORITHMS for the outermost join in the expression.</p> <p>If there are multiple joins in the query, this will return the top (outermost) one. This only works with expressions bound to a DuckDB backend. Other kinds of expressions will raise NotImplementedError.</p>"},{"location":"reference/join/#mismo.joins.check_join_algorithm","title":"mismo.joins.check_join_algorithm","text":"<pre><code>check_join_algorithm(\n    left: Table,\n    right: Table,\n    condition,\n    *,\n    on_slow: Literal[\"error\", \"warn\", \"ignore\"] = \"error\",\n) -&gt; None\n</code></pre> <p>Error or warn if the join in the expression is likely to be slow.</p> <p>Issues a SlowJoinWarning or raises a SlowJoinError.</p> <p>This is only implemented for the duckdb backend. All other backends will issue a warning and skip the check.</p> <p>By \"slow\", we mean that the join algorithm is one of:</p> <ul> <li>\"NESTED_LOOP_JOIN\" O(n*m)</li> <li>\"BLOCKWISE_NL_JOIN\" O(n*m)</li> <li>\"CROSS_PRODUCT\" O(n*m)</li> </ul> <p>and not one of the fast join algorithms:</p> <ul> <li>\"EMPTY_RESULT\" O(1)</li> <li>\"POSITIONAL_JOIN\" O(n)</li> <li>\"HASH_JOIN\" O(n)</li> <li>\"PIECEWISE_MERGE_JOIN\" O(m*log(n))</li> <li>\"IE_JOIN\" O(n*log(n))</li> <li>\"ASOF_JOIN\" O(n*log(n))</li> </ul> <p>This is done by using the EXPLAIN command to generate the query plan, and checking the join algorithm.</p> <p>See https://duckdb.org/2022/05/27/iejoin.html for a very good explanation of these join algorithms.</p>"},{"location":"reference/join/#mismo.joins.JoinAlgorithm","title":"mismo.joins.JoinAlgorithm  <code>module-attribute</code>","text":"<pre><code>JoinAlgorithm = Literal[\n    \"EMPTY_RESULT\",\n    \"LEFT_DELIM_JOIN\",\n    \"RIGHT_DELIM_JOIN\",\n    \"BLOCKWISE_NL_JOIN\",\n    \"NESTED_LOOP_JOIN\",\n    \"HASH_JOIN\",\n    \"PIECEWISE_MERGE_JOIN\",\n    \"IE_JOIN\",\n    \"ASOF_JOIN\",\n    \"CROSS_PRODUCT\",\n    \"POSITIONAL_JOIN\",\n]\n</code></pre>"},{"location":"reference/join/#mismo.joins.SlowJoinAlgorithm","title":"mismo.joins.SlowJoinAlgorithm  <code>module-attribute</code>","text":"<pre><code>SlowJoinAlgorithm = Literal[\n    \"NESTED_LOOP_JOIN\", \"BLOCKWISE_NL_JOIN\", \"CROSS_PRODUCT\"\n]\n</code></pre>"},{"location":"reference/join/#mismo.joins.JOIN_ALGORITHMS","title":"mismo.joins.JOIN_ALGORITHMS  <code>module-attribute</code>","text":"<pre><code>JOIN_ALGORITHMS = frozenset(__args__)\n</code></pre> <p>Based on all the JOIN operators in https://github.com/duckdb/duckdb/blob/b0b1562e293718ee9279c9621cefe4cb5dc01ef9/src/common/enums/physical_operator_type.cpp#L56 (very good) explanation of these at https://duckdb.org/2022/05/27/iejoin.html</p>"},{"location":"reference/join/#mismo.joins.SLOW_JOIN_ALGORITHMS","title":"mismo.joins.SLOW_JOIN_ALGORITHMS  <code>module-attribute</code>","text":"<pre><code>SLOW_JOIN_ALGORITHMS = frozenset(__args__)\n</code></pre>"},{"location":"reference/join/#mismo.exceptions.SlowJoinError","title":"mismo.exceptions.SlowJoinError","text":"<p>               Bases: <code>SlowJoinMixin</code>, <code>ValueError</code>, <code>MismoError</code></p> <p>Error for slow join algorithms.</p>"},{"location":"reference/join/#mismo.exceptions.SlowJoinWarning","title":"mismo.exceptions.SlowJoinWarning","text":"<p>               Bases: <code>SlowJoinMixin</code>, <code>UserWarning</code>, <code>MismoWarning</code></p> <p>Warning for slow join algorithms.</p>"},{"location":"reference/playdata/","title":"Play Data","text":"<p>Load some toy datasets for testing and examples.</p>"},{"location":"reference/playdata/#mismo.playdata.load_patents","title":"mismo.playdata.load_patents","text":"<pre><code>load_patents(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Load the PATSTAT dataset.</p> <p>This represents a dataset of patents, and the task is to determine which patents came from the same inventor.</p> <p>This comes from the Dedupe Patent Example.</p> RETURNS DESCRIPTION <code>Linkage</code> <p>A Linkage, where both <code>left</code> and <code>right</code> are the tables of records. Each one has the following schema:</p> <ul> <li>record_id: uint32   A unique ID for each row in the table.</li> <li>label_true: uint32   The manually labeled, true ID of the inventor.</li> <li>name_true: str   The manually labeled, true name of the inventor.</li> <li>name: str   The raw name on the patent.</li> <li>latitude: float64   Geocoded from the inventor's address. 0.0 indicates no address was found</li> <li>longitude: float64</li> <li>coauthor: str   A list of coauthors on the patent, separated by \"**\"</li> <li>classes: str   A list of 4-character IPC technical codes, separated by \"**\"</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; load_patents().left.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 label_true \u2503 name_true            \u2503 name                                             \u2503 latitude \u2503 longitude \u2503 coauthors                                       \u2503 classes                                         \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 uint32    \u2502 uint32     \u2502 string               \u2502 string                                           \u2502 float64  \u2502 float64   \u2502 string                                          \u2502 string                                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      2909 \u2502     402600 \u2502 AGILENT TECHNOLOGIES \u2502 * AGILENT TECHNOLOGIES, INC.                     \u2502     0.00 \u2502  0.000000 \u2502 KONINK PHILIPS ELECTRONICS N V**DAVID E  SNYDE\u2026 \u2502 A61N**A61B                                      \u2502\n\u2502      3574 \u2502     569309 \u2502 AKZO NOBEL           \u2502 * AKZO NOBEL N.V.                                \u2502     0.00 \u2502  0.000000 \u2502 TSJERK  HOEKSTRA**ANDRESS K  JOHNSON**TERESA M\u2026 \u2502 G01N**B01L**C11D**G02F**F16L                    \u2502\n\u2502      3575 \u2502     569309 \u2502 AKZO NOBEL           \u2502 * AKZO NOBEL NV                                  \u2502     0.00 \u2502  0.000000 \u2502 WILLIAM JOHN ERNEST  PARR**HANS  OSKARSSON**MA\u2026 \u2502 C09K**F17D**B01F**C23F                          \u2502\n\u2502      3779 \u2502     656303 \u2502 ALCATEL              \u2502 * ALCATEL N.V.                                   \u2502    52.35 \u2502  4.916667 \u2502 GUENTER  KOCHSMEIER**ZBIGNIEW  WIEGOLASKI**EVA\u2026 \u2502 G02B**G04G**H02G**G06F                          \u2502\n\u2502      3780 \u2502     656303 \u2502 ALCATEL              \u2502 * ALCATEL N.V.                                   \u2502    52.35 \u2502  4.916667 \u2502 ZILAN  MANFRED**JOSIANE  RAMOS**DUANE LYNN  MO\u2026 \u2502 H03G**B05D**H04L**H04B**C03B**C03C**G02B**H01B  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/playdata/#mismo.playdata.load_rldata500","title":"mismo.playdata.load_rldata500","text":"<pre><code>load_rldata500(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Synthetic personal information dataset with 500 rows</p> <p>This is a synthetic dataset with noisy names and dates of birth, with the task being to determine which rows represent the same person. 10% of the records are duplicates of existing ones, and the level of noise is low. The dataset can be deduplicated with 90%+ precision and recall using simple linkage rules. It is often used as a sanity check for computational efficiency and disambiguation accuracy.</p> <p>This comes from the RecordLinkage R package and was generated using the data generation component of Febrl (Freely Extensible Biomedical Record Linkage).</p> RETURNS DESCRIPTION <code>Linkage</code> <p>A Linkage, where both <code>left</code> and <code>right</code> are the tables of records. Each one has the following schema:</p> <ul> <li>record_id: int64   A unique ID for each row in the table.</li> <li>label_true: int64   The manually labeled, true ID of the inventor.</li> <li>fname_c1: string   First component of the first name.</li> <li>fname_c2: string   Second component of the first name (mostly NULL values)</li> <li>lname_c1: string   First component of the last name.</li> <li>lname_c2: string   Second component of the last name (mostly NULL values).</li> <li>by: int64   Birth year</li> <li>bm: int64   Birth month</li> <li>bd: int64   Birth day</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; load_rldata500().left.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 label_true \u2503 fname_c1 \u2503 fname_c2 \u2503 lname_c1 \u2503 lname_c2 \u2503 by    \u2503 bm    \u2503 bd    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 int64      \u2502 string   \u2502 string   \u2502 string   \u2502 string   \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         0 \u2502         34 \u2502 CARSTEN  \u2502 NULL     \u2502 MEIER    \u2502 NULL     \u2502  1949 \u2502     7 \u2502    22 \u2502\n\u2502         1 \u2502         51 \u2502 GERD     \u2502 NULL     \u2502 BAUER    \u2502 NULL     \u2502  1968 \u2502     7 \u2502    27 \u2502\n\u2502         2 \u2502        115 \u2502 ROBERT   \u2502 NULL     \u2502 HARTMANN \u2502 NULL     \u2502  1930 \u2502     4 \u2502    30 \u2502\n\u2502         3 \u2502        189 \u2502 STEFAN   \u2502 NULL     \u2502 WOLFF    \u2502 NULL     \u2502  1957 \u2502     9 \u2502     2 \u2502\n\u2502         4 \u2502         72 \u2502 RALF     \u2502 NULL     \u2502 KRUEGER  \u2502 NULL     \u2502  1966 \u2502     1 \u2502    13 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/playdata/#mismo.playdata.load_rldata10000","title":"mismo.playdata.load_rldata10000","text":"<pre><code>load_rldata10000(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Synthetic personal information dataset with 10000 rows</p> <p>This is a synthetic dataset with noisy names and dates of birth, with the task being to determine which rows represent the same person. 10% of the records are duplicates of existing ones, and the level of noise is low. The dataset can be deduplicated with 90%+ precision and recall using simple linkage rules. It is often used as a sanity check for computational efficiency and disambiguation accuracy.</p> <p>This comes from the RecordLinkage R package and was generated using the data generation component of Febrl (Freely Extensible Biomedical Record Linkage).</p> RETURNS DESCRIPTION <code>Linkage</code> <p>A Linkage, where both <code>left</code> and <code>right</code> are the tables of records. Each one has the following schema:</p> <ul> <li>record_id: int64   A unique ID for each row in the table.</li> <li>label_true: int64   The manually labeled, true ID of the inventor.</li> <li>fname_c1: string   First component of the first name.</li> <li>fname_c2: string   Second component of the first name (mostly NULL values)</li> <li>lname_c1: string   First component of the last name.</li> <li>lname_c2: string   Second component of the last name (mostly NULL values).</li> <li>by: int64   Birth year</li> <li>bm: int64   Birth month</li> <li>bd: int64   Birth day</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; load_rldata10000().left.head()\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id \u2503 label_true \u2503 fname_c1 \u2503 fname_c2 \u2503 lname_c1   \u2503 lname_c2 \u2503 by    \u2503 bm    \u2503 bd    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64     \u2502 int64      \u2502 string   \u2502 string   \u2502 string     \u2502 string   \u2502 int64 \u2502 int64 \u2502 int64 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         0 \u2502       3606 \u2502 FRANK    \u2502 NULL     \u2502 MUELLER    \u2502 NULL     \u2502  1967 \u2502     9 \u2502    27 \u2502\n\u2502         1 \u2502       2560 \u2502 MARTIN   \u2502 NULL     \u2502 SCHWARZ    \u2502 NULL     \u2502  1967 \u2502     2 \u2502    17 \u2502\n\u2502         2 \u2502       3892 \u2502 HERBERT  \u2502 NULL     \u2502 ZIMMERMANN \u2502 NULL     \u2502  1961 \u2502    11 \u2502     6 \u2502\n\u2502         3 \u2502        329 \u2502 HANS     \u2502 NULL     \u2502 SCHMITT    \u2502 NULL     \u2502  1945 \u2502     8 \u2502    14 \u2502\n\u2502         4 \u2502       1994 \u2502 UWE      \u2502 NULL     \u2502 KELLER     \u2502 NULL     \u2502  2000 \u2502     7 \u2502     5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/playdata/#mismo.playdata.load_febrl1","title":"mismo.playdata.load_febrl1","text":"<pre><code>load_febrl1(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Load the FEBRL 1 dataset.</p> <p>The Freely Extensible Biomedical Record Linkage (Febrl) package is distributed with a dataset generator and four datasets generated with the generator.</p>"},{"location":"reference/playdata/#mismo.playdata.load_febrl2","title":"mismo.playdata.load_febrl2","text":"<pre><code>load_febrl2(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Load the FEBRL 2 dataset.</p> <p>The Freely Extensible Biomedical Record Linkage (Febrl) package is distributed with a dataset generator and four datasets generated with the generator.</p>"},{"location":"reference/playdata/#mismo.playdata.load_febrl3","title":"mismo.playdata.load_febrl3","text":"<pre><code>load_febrl3(\n    *, backend: BaseBackend | None = None\n) -&gt; Linkage\n</code></pre> <p>Load the FEBRL 3 dataset.</p> <p>The Freely Extensible Biomedical Record Linkage (Febrl) package is distributed with a dataset generator and four datasets generated with the generator.</p>"},{"location":"reference/sets/","title":"Set Utils","text":"<p>Utilities for set- and bag-of-word-based models.</p> <p>For example, split text into a collection of tokens (usually words or ngrams), then count the number of times they appear in each document or in the collection of documents.</p> <p>This also is relevant for other sorts of unordered collections. For example, movies might be tagged with multiple genres such as \"fantasy\" and \"action\".</p>"},{"location":"reference/sets/#sets","title":"Sets","text":""},{"location":"reference/sets/#mismo.sets.jaccard","title":"mismo.sets.jaccard","text":"<pre><code>jaccard(a: ArrayValue, b: ArrayValue) -&gt; FloatingValue\n</code></pre> <p>The Jaccard similarity between two arrays.</p> PARAMETER DESCRIPTION <code>a</code> <p>The first array.</p> <p> TYPE: <code>ArrayValue</code> </p> <code>b</code> <p>The second array.</p> <p> TYPE: <code>ArrayValue</code> </p> RETURNS DESCRIPTION <code>FloatingValue</code> <p>The Jaccard similarity between the two arrays.</p>"},{"location":"reference/sets/#bag-of-words","title":"Bag-Of-Words","text":""},{"location":"reference/sets/#mismo.sets.add_array_value_counts","title":"mismo.sets.add_array_value_counts","text":"<pre><code>add_array_value_counts(\n    t: Table,\n    column: str,\n    *,\n    result_name: str = \"{name}_counts\",\n) -&gt; Table\n</code></pre> <p>value_counts() for ArrayColumns.</p> PARAMETER DESCRIPTION <code>t</code> <p>The input table.</p> <p> TYPE: <code>Table</code> </p> <code>column</code> <p>The name of the array column to analyze.</p> <p> TYPE: <code>str</code> </p> <code>result_name</code> <p>The name of the resulting column. The default is \"{name}_counts\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{name}_counts'</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.sets import add_array_value_counts\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; ibis.options.repr.interactive.max_length = 20\n&gt;&gt;&gt; terms = [\n...     None,\n...     [\"st\"],\n...     [\"st\"],\n...     [\"12\", \"main\", \"st\"],\n...     [\"99\", \"main\", \"ave\"],\n...     [\"56\", \"st\", \"joseph\", \"st\"],\n...     [\"21\", \"glacier\", \"st\"],\n...     [\"12\", \"glacier\", \"st\"],\n... ]\n&gt;&gt;&gt; t = ibis.memtable({\"terms\": terms})\n&gt;&gt;&gt; add_array_value_counts(t, \"terms\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 terms                        \u2503 terms_counts                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array&lt;string&gt;                \u2502 map&lt;string, int64&gt;               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['st']                       \u2502 {'st': 1}                        \u2502\n\u2502 ['st']                       \u2502 {'st': 1}                        \u2502\n\u2502 ['12', 'main', 'st']         \u2502 {'st': 1, '12': 1, 'main': 1}    \u2502\n\u2502 ['99', 'main', 'ave']        \u2502 {'ave': 1, '99': 1, 'main': 1}   \u2502\n\u2502 ['56', 'st', 'joseph', 'st'] \u2502 {'56': 1, 'joseph': 1, 'st': 2}  \u2502\n\u2502 ['21', 'glacier', 'st']      \u2502 {'glacier': 1, 'st': 1, '21': 1} \u2502\n\u2502 ['12', 'glacier', 'st']      \u2502 {'glacier': 1, 'st': 1, '12': 1} \u2502\n\u2502 NULL                         \u2502 NULL                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/sets/#mismo.sets.add_tfidf","title":"mismo.sets.add_tfidf","text":"<pre><code>add_tfidf(\n    t,\n    column: str,\n    *,\n    result_name: str = \"{name}_tfidf\",\n    normalize: bool = True,\n)\n</code></pre> <p>Vectorize terms using TF-IDF.</p> <p>Adds a column to the input table that contains the TF-IDF vector for the terms in the input column.</p> PARAMETER DESCRIPTION <code>t</code> <p>The input table.</p> <p> TYPE: <code>Table</code> </p> <code>column</code> <p>The name of the array column to analyze.</p> <p> TYPE: <code>str</code> </p> <code>result_name</code> <p>The name of the resulting column. The default is \"{name}_tfidf\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{name}_tfidf'</code> </p> <code>normalize</code> <p>Whether to normalize the TF-vector before multiplying by the IDF. The default is True. This makes it so that vectors of different lengths can be compared fairly.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.sets import add_tfidf\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; ibis.options.repr.interactive.max_length = 20\n&gt;&gt;&gt; terms = [\n...     None,\n...     [\"st\"],\n...     [\"st\"],\n...     [\"12\", \"main\", \"st\"],\n...     [\"99\", \"main\", \"ave\"],\n...     [\"56\", \"st\", \"joseph\", \"st\"],\n...     [\"21\", \"glacier\", \"st\"],\n...     [\"12\", \"glacier\", \"st\"],\n... ]\n&gt;&gt;&gt; t = ibis.memtable({\"terms\": terms})\n&gt;&gt;&gt; add_tfidf(t, \"terms\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 terms                        \u2503 terms_tfidf                                                                          \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 array&lt;string&gt;                \u2502 map&lt;string, float64&gt;                                                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ['st']                       \u2502 {'st': 0.15415067982725836}                                                          \u2502\n\u2502 ['st']                       \u2502 {'st': 0.15415067982725836}                                                          \u2502\n\u2502 ['12', 'glacier', 'st']      \u2502 {'12': 0.7232830370915955, 'glacier': 0.7232830370915955, 'st': 0.08899893649403144} \u2502\n\u2502 ['12', 'main', 'st']         \u2502 {'12': 0.7232830370915955, 'main': 0.7232830370915955, 'st': 0.08899893649403144}    \u2502\n\u2502 ['21', 'glacier', 'st']      \u2502 {'21': 1.12347174837591, 'glacier': 0.7232830370915955, 'st': 0.08899893649403144}   \u2502\n\u2502 ['56', 'st', 'joseph', 'st'] \u2502 {'56': 0.7944144917481126, 'joseph': 0.7944144917481126, 'st': 0.12586350302664107}  \u2502\n\u2502 ['99', 'main', 'ave']        \u2502 {'main': 0.7232830370915955, 'ave': 1.12347174837591, '99': 1.12347174837591}        \u2502\n\u2502 NULL                         \u2502 NULL                                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/sets/#mismo.sets.document_counts","title":"mismo.sets.document_counts","text":"<pre><code>document_counts(terms: ArrayColumn) -&gt; Table\n</code></pre> <p>Create a lookup Table from term to number of records containing the term.</p> PARAMETER DESCRIPTION <code>terms</code> <p>One row for each record. Each row is an array of terms in that record. Each term could be a word, ngram, or other token from a string. Or, it could also represent more generic data, such as a list of tags or categories like [\"red\", \"black\"]. Each term can be any datatype, not just strings.</p> <p> TYPE: <code>ArrayColumn</code> </p> RETURNS DESCRIPTION <code>    A Table with columns `term` and `n_records`. The `term` column contains</code> <p>each unique term from the input <code>terms</code> array. The <code>n_records</code> column contains the number of records in the input <code>terms</code> array that contain</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from mismo.sets import document_counts\n&gt;&gt;&gt; addresses = [\n...     \"12 main st\",\n...     \"99 main ave\",\n...     \"56 st joseph st\",\n...     \"21 glacier st\",\n...     \"12 glacier st\",\n... ]\n&gt;&gt;&gt; t = ibis.memtable({\"address\": addresses})\n&gt;&gt;&gt; # split on whitespace\n&gt;&gt;&gt; t = t.mutate(terms=t.address.re_split(r\"\\s+\"))\n&gt;&gt;&gt; document_counts(t.terms).order_by(\"term\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 term    \u2503 n_records \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 12      \u2502         2 \u2502\n\u2502 21      \u2502         1 \u2502\n\u2502 56      \u2502         1 \u2502\n\u2502 99      \u2502         1 \u2502\n\u2502 ave     \u2502         1 \u2502\n\u2502 glacier \u2502         2 \u2502\n\u2502 joseph  \u2502         1 \u2502\n\u2502 main    \u2502         2 \u2502\n\u2502 st      \u2502         4 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/sets/#mismo.sets.rare_terms","title":"mismo.sets.rare_terms","text":"<pre><code>rare_terms(\n    terms: ArrayColumn,\n    *,\n    max_records_n: int | None = None,\n    max_records_frac: float | None = None,\n) -&gt; Column\n</code></pre> <p>Get the terms that appear in few records.</p> <p>The returned Column is flattened. Eg if you supply a column of <code>array&lt;string&gt;</code>, the result will be of type <code>string</code>.</p> <p>Exactly one of <code>max_records_n</code> or <code>max_records_frac</code> must be set.</p> PARAMETER DESCRIPTION <code>terms</code> <p>A column of Arrays, where each array contains the terms for a record.</p> <p> TYPE: <code>ArrayColumn</code> </p> <code>max_records_n</code> <p>The maximum number of records a term can appear in. The default is None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>max_records_frac</code> <p>The maximum fraction of records a term can appear in. The default is None.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Column</code> <p>The terms that appear in few records.</p>"},{"location":"reference/sets/#mismo.sets.term_idf","title":"mismo.sets.term_idf","text":"<pre><code>term_idf(terms: ArrayValue) -&gt; Table\n</code></pre> <p>Create a lookup Table from term to IDF.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.sets import term_idf\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; addresses = [\n...     \"12 main st\",\n...     \"99 main ave\",\n...     \"56 st joseph st\",\n...     \"21 glacier st\",\n...     \"12 glacier st\",\n... ]\n&gt;&gt;&gt; t = ibis.memtable({\"address\": addresses})\n&gt;&gt;&gt; # split on whitespace\n&gt;&gt;&gt; t = t.mutate(terms=t.address.re_split(r\"\\s+\"))\n&gt;&gt;&gt; term_idf(t.terms).order_by(\"term\")\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 term    \u2503 idf      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 string  \u2502 float64  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 12      \u2502 0.916291 \u2502\n\u2502 21      \u2502 1.609438 \u2502\n\u2502 56      \u2502 1.609438 \u2502\n\u2502 99      \u2502 1.609438 \u2502\n\u2502 ave     \u2502 1.609438 \u2502\n\u2502 glacier \u2502 0.916291 \u2502\n\u2502 joseph  \u2502 1.609438 \u2502\n\u2502 main    \u2502 0.916291 \u2502\n\u2502 st      \u2502 0.223144 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/text/","title":"Text API","text":""},{"location":"reference/text/#mismo.text.norm_whitespace","title":"mismo.text.norm_whitespace","text":"<pre><code>norm_whitespace(texts: StringValue) -&gt; StringValue\n</code></pre> <p>Strip leading/trailing whitespace, replace multiple whitespace with a single space.</p>"},{"location":"reference/text/#mismo.text.strip_accents","title":"mismo.text.strip_accents","text":"<pre><code>strip_accents(s: StringValue) -&gt; StringValue\n</code></pre> <p>Remove accents, such as \u00e9 -&gt; e. Only works with duckdb.</p> PARAMETER DESCRIPTION <code>s</code> <p>The string to strip</p> <p> TYPE: <code>StringValue</code> </p> RETURNS DESCRIPTION <code>StringValue</code> <p>The string with non-ascii characters replaced and/or removed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; strip_accents(ibis.literal(\"m\u00fcller\")).execute()\n'muller'\n&gt;&gt;&gt; strip_accents(ibis.literal(\"Fran\u00e7ois\")).execute()\n'Francois'\n&gt;&gt;&gt; strip_accents(ibis.literal(\"\u00d8slo\")).execute()  # \u00d8 is not an accent\n'\u00d8slo'\n&gt;&gt;&gt; strip_accents(ibis.literal(\"\u00e6\")).execute()  # neither is this\n'\u00e6'\n&gt;&gt;&gt; strip_accents(ibis.literal(\"\u0251\u027d\u2c64oW\")).execute()  # neither is this\n'\u0251\u027d\u2c64oW'\n</code></pre>"},{"location":"reference/text/#mismo.text.ngrams","title":"mismo.text.ngrams","text":"<pre><code>ngrams(string: StringValue, n: int) -&gt; ArrayValue\n</code></pre> <p>Character n-grams from a string. The order of the n-grams is not guaranteed.</p> PARAMETER DESCRIPTION <code>string</code> <p>The string to generate n-grams from.</p> <p> TYPE: <code>StringValue</code> </p> <code>n</code> <p>The number of characters in each n-gram.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>An array of n-grams.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.text import ngrams\n&gt;&gt;&gt; ngrams(\"abc\", 2).execute()\n['ab', 'bc']\n&gt;&gt;&gt; ngrams(\"\", 2).execute()\n[]\n&gt;&gt;&gt; ngrams(\"a\", 2).execute()\n[]\n&gt;&gt;&gt; ngrams(None, 4).execute() is None\nTrue\n</code></pre> <p>Order of n-grams is not guaranteed:</p> <pre><code>&gt;&gt;&gt; ngrams(\"abcdef\", 3).execute()\n['abc', 'def', 'bcd', 'cde']\n</code></pre>"},{"location":"reference/text/#mismo.text.tokenize","title":"mismo.text.tokenize","text":"<pre><code>tokenize(text: StringValue) -&gt; ArrayValue\n</code></pre> <p>Split a string into tokens on whitespace.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.text import tokenize\n&gt;&gt;&gt; tokenize(ibis.literal(\"  abc    def\")).execute()\n['abc', 'def']\n&gt;&gt;&gt; tokenize(ibis.literal(\"  abc\")).execute()\n['abc']\n&gt;&gt;&gt; tokenize(ibis.literal(\" \")).execute()\n[]\n&gt;&gt;&gt; tokenize(ibis.null(str)).execute() is None\nTrue\n</code></pre>"},{"location":"reference/text/#mismo.text.double_metaphone","title":"mismo.text.double_metaphone","text":"<pre><code>double_metaphone(s: StringValue) -&gt; ArrayValue[StringValue]\n</code></pre> <p>Double Metaphone phonetic encoding</p> <p>This requires the doublemetaphone package to be installed. You can install it with <code>python -m pip install DoubleMetaphone</code>. This uses a python UDF so it is going to be slow.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from mismo.text import double_metaphone\n&gt;&gt;&gt; double_metaphone(\"catherine\").execute()\n['K0RN', 'KTRN']\n&gt;&gt;&gt; double_metaphone(\"\").execute()\n['', '']\n&gt;&gt;&gt; double_metaphone(None).execute() is None\nTrue\n</code></pre>"},{"location":"reference/text/#mismo.text.levenshtein_ratio","title":"mismo.text.levenshtein_ratio","text":"<pre><code>levenshtein_ratio(\n    s1: StringValue, s2: StringValue\n) -&gt; FloatingValue\n</code></pre> <p>The levenshtein distance between two strings, normalized to be between 0 and 1.</p> <p>The ratio is defined as <code>(lenmax - ldist)/lenmax</code> where</p> <ul> <li><code>ldist</code> is the regular levenshtein distance</li> <li><code>lenmax</code> is the maximum length of the two strings   (eg the largest possible edit distance)</li> </ul> <p>This makes it so that the ratio is 1 when the strings are the same and 0 when they are completely different. By doing this normalization, the ratio is always between 0 and 1, regardless of the length of the strings.</p> PARAMETER DESCRIPTION <code>s1</code> <p>The first string</p> <p> TYPE: <code>StringValue</code> </p> <code>s2</code> <p>The second string</p> <p> TYPE: <code>StringValue</code> </p> RETURNS DESCRIPTION <code>lev_ratio</code> <p>The ratio of the Levenshtein edit cost to the maximum string length</p> <p> TYPE: <code>FloatingValue</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from mismo.text import levenshtein_ratio\n&gt;&gt;&gt; levenshtein_ratio(\"mile\", \"mike\").execute()\n0.75\n&gt;&gt;&gt; levenshtein_ratio(\"mile\", \"mile\").execute()\n1.0\n&gt;&gt;&gt; levenshtein_ratio(\"mile\", \"\").execute()\n0.0\n&gt;&gt;&gt; levenshtein_ratio(\"\", \"\").execute()\nnan\n</code></pre>"},{"location":"reference/text/#mismo.text.damerau_levenshtein","title":"mismo.text.damerau_levenshtein","text":"<pre><code>damerau_levenshtein(a: str, b: str) -&gt; int\n</code></pre> <p>The number of adds, deletes, substitutions, and transposes to get from <code>a</code> to <code>b</code>.</p> <p>This is the levenstein distance with the addition of transpositions as a possible operation.</p>"},{"location":"reference/text/#mismo.text.damerau_levenshtein_ratio","title":"mismo.text.damerau_levenshtein_ratio","text":"<pre><code>damerau_levenshtein_ratio(\n    s1: StringValue, s2: StringValue\n) -&gt; FloatingValue\n</code></pre> <p>Like levenshtein_ratio, but with the Damerau-Levenshtein distance.</p> See Also <ul> <li>damerau_levenshtein()</li> <li>levenshtein_ratio()</li> </ul>"},{"location":"reference/text/#mismo.text.jaro_similarity","title":"mismo.text.jaro_similarity","text":"<pre><code>jaro_similarity(\n    s1: StringValue, s2: StringValue\n) -&gt; FloatingValue\n</code></pre> <p>The jaro similarity between <code>s1</code> and <code>s2</code>.</p> <p>This is a number between 0 and 1, defined as <code>sj = 1/3 * (m/l_1 + m/l_2 + (m-t)/m)</code></p> <p>where <code>m</code> is the number of matching characters between s1 and s2 and <code>t</code> is the number of transpositions between <code>s1</code> and <code>s2</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.text import jaro_similarity\n&gt;&gt;&gt; jaro_similarity(ibis.literal(\"foo\"), ibis.literal(\"foo\")).execute()\n1.0\n&gt;&gt;&gt; jaro_similarity(ibis.literal(\"foo\"), ibis.literal(\"food\")).execute()\n0.9166666666666666\n&gt;&gt;&gt; jaro_similarity(ibis.null(str), ibis.literal(\"food\")).execute()\nnan\n</code></pre> <p>Be aware: comparing to an empty string always has a similarity of 0:</p> <pre><code>&gt;&gt;&gt; jaro_similarity(ibis.literal(\"a\"), ibis.literal(\"\")).execute()\n0.0\n&gt;&gt;&gt; jaro_similarity(ibis.literal(\"\"), ibis.literal(\"\")).execute()\n0.0\n</code></pre>"},{"location":"reference/text/#mismo.text.jaro_winkler_similarity","title":"mismo.text.jaro_winkler_similarity","text":"<pre><code>jaro_winkler_similarity(\n    s1: StringValue, s2: StringValue\n) -&gt; FloatingValue\n</code></pre> <p>The Jaro-Winkler similarity between <code>s1</code> and <code>s2</code>.</p> <p>The Jaro-Winkler similarity is a variant of the Jaro similarity that measures the number of edits between two strings and places a higher importance on the prefix.</p> <p>It is defined as <code>(sjw = sj + l * p * (1-sj)</code> where <code>sj</code> is the Jaro similarity, <code>l</code> is the length of the common prefix  (up to a maximum of 4) and <code>p</code> is a constant scaling factor (up to a maximum of 0.25, but typically set to 0.1)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.text import jaro_winkler_similarity\n&gt;&gt;&gt; jaro_winkler_similarity(ibis.literal(\"foo\"), ibis.literal(\"foo\")).execute()\n1.0\n&gt;&gt;&gt; jaro_winkler_similarity(ibis.literal(\"foo\"), ibis.literal(\"food\")).execute()\n0.9416666666666667\n&gt;&gt;&gt; jaro_winkler_similarity(ibis.null(str), ibis.literal(\"food\")).execute()\nnan\n</code></pre> <p>Be aware: comparing to an empty string always has a similarity of 0:</p> <pre><code>&gt;&gt;&gt; jaro_winkler_similarity(ibis.literal(\"a\"), ibis.literal(\"\")).execute()\n0.0\n&gt;&gt;&gt; jaro_winkler_similarity(ibis.literal(\"\"), ibis.literal(\"\")).execute()\n0.0\n</code></pre>"},{"location":"reference/vectors/","title":"Vector API","text":"<p>Utilities for manipulating vector data. Vectors can either be represented as dense (using <code>array&lt;numeric&gt;</code>) or sparse (using <code>map&lt;any_type, numeric&gt;</code>)</p>"},{"location":"reference/vectors/#mismo.vector.norm","title":"mismo.vector.norm","text":"<pre><code>norm(\n    vec: T, *, metric: Literal[\"l1\", \"l2\"] = \"l2\"\n) -&gt; FloatingValue\n</code></pre> <p>Compute the norm (length) of a vector.</p> <p>The vector can either be a dense vector, represented as array, or a sparse vector, represented as map. PARAMETER DESCRIPTION <code>vec</code> <p>The vector to compute the norm of.</p> <p> TYPE: <code>T</code> </p> <code>metric</code> <p>The metric to use. \"l1\" for Manhattan distance, \"l2\" for Euclidean distance.</p> <p> TYPE: <code>('l1', 'l2')</code> DEFAULT: <code>\"l1\"</code> </p> RETURNS DESCRIPTION <code>The norm of the vector.</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.vector import norm\n&gt;&gt;&gt; v = ibis.array([-3, 4])\n&gt;&gt;&gt; norm(v).execute()\n5.0\n&gt;&gt;&gt; m = ibis.map({\"a\": -3, \"b\": 4})\n&gt;&gt;&gt; norm(m, metric=\"l1\").execute()\n7.0\n</code></pre>"},{"location":"reference/vectors/#mismo.vector.normalize","title":"mismo.vector.normalize","text":"<pre><code>normalize(\n    vec: T, *, metric: Literal[\"l1\", \"l2\"] = \"l2\"\n) -&gt; T\n</code></pre> <p>Normalize a vector to have unit length.</p> <p>The vector can either be a dense vector, represented as array, or a sparse vector, represented as map. The returned vector will have the same type as the input vector. PARAMETER DESCRIPTION <code>vec</code> <p>The vector to normalize.</p> <p> TYPE: <code>T</code> </p> <code>metric</code> <p>The metric to use. \"l1\" for Manhattan distance, \"l2\" for Euclidean distance.</p> <p> TYPE: <code>('l1', 'l2')</code> DEFAULT: <code>\"l1\"</code> </p> RETURNS DESCRIPTION <code>ArrayValue</code> <p>The normalized vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from mismo.vector import normalize\n&gt;&gt;&gt; normalize(ibis.array([1, 2])).execute()\n[0.4472135954999579, 0.8944271909999159]\n&gt;&gt;&gt; normalize(ibis.array([1, 2]), metric=\"l1\").execute()\n[0.3333333333333333, 0.6666666666666666]\n&gt;&gt;&gt; normalize(ibis.map({\"a\": 1, \"b\": 2})).execute()\n{'a': 0.4472135954999579, 'b': 0.8944271909999159}\n</code></pre>"},{"location":"reference/vectors/#mismo.vector.dot","title":"mismo.vector.dot","text":"<pre><code>dot(a: T, b: T) -&gt; FloatingValue\n</code></pre> <p>Compute the dot product of two vectors</p> <p>The vectors can either be dense vectors, represented as array, or sparse vectors, represented as map. Both vectors must be of the same type though. PARAMETER DESCRIPTION <code>a</code> <p>The first vector.</p> <p> TYPE: <code>T</code> </p> <code>b</code> <p>The second vector.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>FloatingValue</code> <p>The dot product of the two vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.vector import dot\n&gt;&gt;&gt; v1 = ibis.array([1, 2])\n&gt;&gt;&gt; v2 = ibis.array([4, 5])\n&gt;&gt;&gt; dot(v1, v2).execute()  # 1*4 + 2*5\n14.0\n&gt;&gt;&gt; m1 = ibis.map({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; m2 = ibis.map({\"b\": 3, \"c\": 4})\n&gt;&gt;&gt; dot(m1, m2).execute()  # 2*3\n6.0\n</code></pre>"},{"location":"reference/vectors/#mismo.vector.cosine_similarity","title":"mismo.vector.cosine_similarity","text":"<pre><code>cosine_similarity(a: T, b: T) -&gt; FloatingValue\n</code></pre> <p>Compute the cosine similarity of two vectors</p> <p>The vectors can either be dense vectors, represented as array, or sparse vectors, represented as map. Both vectors must be of the same type though. PARAMETER DESCRIPTION <code>a</code> <p>The first vector.</p> <p> TYPE: <code>T</code> </p> <code>b</code> <p>The second vector.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>FloatingValue</code> <p>The cosine similarity of the two vectors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.vector import cosine_similarity\n</code></pre> <p>Opposite directions:</p> <pre><code>&gt;&gt;&gt; cosine_similarity(\n...     ibis.array([1, 1]), ibis.array([-2, -2])\n... ).execute()\n-1.0\n</code></pre> <p>Orthogonal vectors:</p> <pre><code>&gt;&gt;&gt; cosine_similarity(ibis.array([1, 0]), ibis.array([0, 1])).execute()\n0.0\n</code></pre>"},{"location":"reference/vectors/#mismo.vector.mul","title":"mismo.vector.mul","text":"<pre><code>mul(a: T, b: T) -&gt; T\n</code></pre> <p>Element-wise multiplication of two vectors</p>"},{"location":"reference/lib/email/","title":"Emails API","text":"<p>This contains utilities, blockers, and comparers relevant to email addresses</p>"},{"location":"reference/lib/email/#mismo.lib.email.clean_email","title":"mismo.lib.email.clean_email","text":"<pre><code>clean_email(\n    email: StringValue, *, normalize: bool = False\n) -&gt; StringValue\n</code></pre> <p>Clean an email address.</p> <ul> <li>convert to lowercase</li> <li>extract anything that matches r\".(\\S+@\\S+).\"</li> </ul> <p>If <code>normalize</code> is True, an additional step of removing \".\" and \"_\" is performed. This makes it possible to compare two addresses and be more immune to noise. For example, in many email systems such as gmail, \".\" are ignored.</p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail","title":"mismo.lib.email.ParsedEmail","text":"<p>A simple data class holding an email address that has been split into parts.</p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail.domain","title":"mismo.lib.email.ParsedEmail.domain  <code>instance-attribute</code>","text":"<pre><code>domain: StringValue = nullif('')\n</code></pre> <p>The domain part of the email address, eg 'gmail.com'.</p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail.full","title":"mismo.lib.email.ParsedEmail.full  <code>instance-attribute</code>","text":"<pre><code>full: StringValue = full\n</code></pre> <p>The full email address, eg 'bob.smith@gmail.com'.</p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail.user","title":"mismo.lib.email.ParsedEmail.user  <code>instance-attribute</code>","text":"<pre><code>user: StringValue = nullif('')\n</code></pre> <p>The user part of the email address, eg 'bob.smith' of 'bob.smith@gmail.com'</p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail.__init__","title":"mismo.lib.email.ParsedEmail.__init__","text":"<pre><code>__init__(full: StringValue)\n</code></pre> <p>Parse an email address from the full string.</p> <p>Does no cleaning or normalization. If you want that, use <code>clean_email</code> first.</p> PARAMETER DESCRIPTION <code>full</code> <p>The full email address.</p> <p> TYPE: <code>StringValue</code> </p>"},{"location":"reference/lib/email/#mismo.lib.email.ParsedEmail.as_struct","title":"mismo.lib.email.ParsedEmail.as_struct","text":"<pre><code>as_struct() -&gt; StructValue\n</code></pre> <p>Convert to an ibis struct.</p> RETURNS DESCRIPTION <code>An ibis struct&lt;full:string, user:string, domain: domain&gt;</code>"},{"location":"reference/lib/email/#mismo.lib.email.match_level","title":"mismo.lib.email.match_level","text":"<pre><code>match_level(\n    e1: StructValue | StringValue,\n    e2: StructValue | StringValue,\n    *,\n    native_representation: Literal[\n        \"integer\", \"string\"\n    ] = \"integer\",\n) -&gt; EmailMatchLevel\n</code></pre> <p>Match level of two email addresses.</p> PARAMETER DESCRIPTION <code>e1</code> <p>The first email address. If a string, it will be parsed and normalized.</p> <p> TYPE: <code>StructValue | StringValue</code> </p> <code>e2</code> <p>The second email address. If a string, it will be parsed and normalized.</p> <p> TYPE: <code>StructValue | StringValue</code> </p> RETURNS DESCRIPTION <code>level</code> <p>The match level.</p> <p> TYPE: <code>EmailMatchLevel</code> </p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel","title":"mismo.lib.email.EmailMatchLevel","text":"<p>               Bases: <code>MatchLevel</code></p> <p>How closely two email addresses of the form <code>&lt;user&gt;@&lt;domain&gt;</code> match.</p> <p>Case is ignored, and dots and underscores are removed.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel.ELSE","title":"mismo.lib.email.EmailMatchLevel.ELSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELSE = 4\n</code></pre> <p>None of the above.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel.FULL_EXACT","title":"mismo.lib.email.EmailMatchLevel.FULL_EXACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_EXACT = 0\n</code></pre> <p>The full email addresses are exactly the same.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel.FULL_NEAR","title":"mismo.lib.email.EmailMatchLevel.FULL_NEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_NEAR = 1\n</code></pre> <p>The full email addresses have a small edit distance.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel.USER_EXACT","title":"mismo.lib.email.EmailMatchLevel.USER_EXACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER_EXACT = 2\n</code></pre> <p>The user part of the email addresses are exactly the same.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailMatchLevel.USER_NEAR","title":"mismo.lib.email.EmailMatchLevel.USER_NEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER_NEAR = 3\n</code></pre> <p>The user part of the email addresses have a small edit distance.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailsDimension","title":"mismo.lib.email.EmailsDimension","text":"<p>A dimension of email addresses.</p> <p>This is useful if each record contains a collection of email addresses. Two records are probably the same if they have a lot of email addresses in common.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailsDimension.__init__","title":"mismo.lib.email.EmailsDimension.__init__","text":"<pre><code>__init__(\n    column: str,\n    *,\n    column_parsed: str = \"{column}_parsed\",\n    column_compared: str = \"{column}_compared\",\n)\n</code></pre> <p>Initialize the dimension.</p> PARAMETER DESCRIPTION <code>column</code> <p>The name of the column that holds a array of email addresses. <p> TYPE: <code>str</code> </p> <code>column_parsed</code> <p>The name of the column that will be filled with the parsed email addresses.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{column}_parsed'</code> </p> <code>column_compared</code> <p>The name of the column that will be filled with the comparison results.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{column}_compared'</code> </p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailsDimension.compare","title":"mismo.lib.email.EmailsDimension.compare","text":"<pre><code>compare(t: Table) -&gt; Table\n</code></pre> <p>Add a column with the best match between all pairs of email addresses.</p>"},{"location":"reference/lib/email/#mismo.lib.email.EmailsDimension.prepare_for_fast_linking","title":"mismo.lib.email.EmailsDimension.prepare_for_fast_linking","text":"<pre><code>prepare_for_fast_linking(t: Table) -&gt; Table\n</code></pre> <p>Add a column with the parsed and normalized email addresses.</p>"},{"location":"reference/lib/geo/","title":"Geospatial API","text":"<p>This contains utilities, Linkers, and comparers relevant to geospatial data.</p>"},{"location":"reference/lib/geo/#coordinates","title":"Coordinates","text":""},{"location":"reference/lib/geo/#mismo.lib.geo.CoordinateLinker","title":"mismo.lib.geo.CoordinateLinker  <code>dataclass</code>","text":"<p>Links two locations together if they are within a certain distance.</p> <p>This isn't precise, and can include pairs that are actually up to about 2x larger than the given threshold. This is because we use a simple grid to bin the coordinates, so 1. This isn't accurate near the poles, and 2. This isn't accurate near the international date line (longitude 180/-180). 3. If two coords fall within opposite corners of the same grid cell, they     will be blocked together even if they are further apart than the     precision, due to the diagonal distance being longer than the horizontal     or vertical distance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from mismo.lib.geo import CoordinateLinker\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; conn = ibis.duckdb.connect()\n&gt;&gt;&gt; left = conn.create_table(\n...     \"left\",\n...     [\n...         {\n...             \"record_id\": 0,\n...             \"latlon\": {\"lat\": 61.1547800, \"lon\": -150.0677490},\n...         }\n...     ],\n... )\n&gt;&gt;&gt; right = conn.create_table(\n...     \"right\",\n...     [\n...         {\n...             \"record_id\": 4,\n...             \"latitude\": 61.1582056,\n...             \"longitude\": -150.0584552,\n...         },\n...         {\n...             \"record_id\": 5,\n...             \"latitude\": 61.1582056,\n...             \"longitude\": 0,\n...         },\n...         {\n...             \"record_id\": 6,\n...             \"latitude\": 61.1547800,\n...             \"longitude\": -150,\n...         },\n...     ],\n... )\n&gt;&gt;&gt; linker = CoordinateLinker(\n...     distance_km=1,\n...     left_resolver=\"latlon\",\n...     right_resolver={\"lat\": \"latitude\", \"lon\": \"longitude\"},\n... )\n&gt;&gt;&gt; linker(left, right).links\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 record_id_l \u2503 latlon_l                      \u2503 record_id_r \u2503 latitude_r \u2503 longitude_r \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 int64       \u2502 struct&lt;lat: float64, lon:     \u2502 int64       \u2502 float64    \u2502 float64     \u2502\n\u2502             \u2502 float64&gt;                      \u2502             \u2502            \u2502             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             \u2502 {                             \u2502             \u2502            \u2502             \u2502\n\u2502           0 \u2502     'lat': 61.15478,          \u2502           4 \u2502  61.158206 \u2502 -150.058455 \u2502\n\u2502             \u2502     'lon': -150.067749        \u2502             \u2502            \u2502             \u2502\n\u2502             \u2502 }                             \u2502             \u2502            \u2502             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reference/lib/geo/#mismo.lib.geo.CoordinateLinker.distance_km","title":"mismo.lib.geo.CoordinateLinker.distance_km  <code>instance-attribute</code>","text":"<pre><code>distance_km: float | int\n</code></pre> <p>The (approx) max distance in kilometers that two coords will be blocked together.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.CoordinateLinker.left_resolver","title":"mismo.lib.geo.CoordinateLinker.left_resolver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>left_resolver: IntoCoordinates = field(\n    default_factory=default_resolver\n)\n</code></pre> <p>A specification of how to get the lat and lon values from the left table.</p> <p>Can be: - A <code>str</code> or <code>ibis.Deferred</code>, which are assumed to point to a column   containing a struct with <code>lat</code> and <code>lon</code> fields. - A <code>Mapping</code> of <code>{\"lat\": ..., \"lon\": ...}</code> where the values are   column names or <code>ibis.Deferred</code> expressions. - A callable that takes a table and returns one of the above.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.CoordinateLinker.max_pairs","title":"mismo.lib.geo.CoordinateLinker.max_pairs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_pairs: int | None = None\n</code></pre> <p>The maximum number of pairs that any single block of coordinates can contain.</p> <p>eg if you have 1000 records all with the same coordinates, this would naively result in ~(1000 * 1000) / 2 = 500_000 pairs. If we set max_pairs to less than this, this group of records will be skipped.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.CoordinateLinker.right_resolver","title":"mismo.lib.geo.CoordinateLinker.right_resolver  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>right_resolver: IntoCoordinates = field(\n    default_factory=default_resolver\n)\n</code></pre> <p>See <code>left_resolver</code>, but for the right table.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.distance_km","title":"mismo.lib.geo.distance_km","text":"<pre><code>distance_km(\n    *,\n    lat1: FloatingValue,\n    lon1: FloatingValue,\n    lat2: FloatingValue,\n    lon2: FloatingValue,\n) -&gt; FloatingValue\n</code></pre> <p>The distance between two points on the Earth's surface, in kilometers.</p> PARAMETER DESCRIPTION <code>lat1</code> <p>The latitude of the first point.</p> <p> TYPE: <code>FloatingValue</code> </p> <code>lon1</code> <p>The longitude of the first point.</p> <p> TYPE: <code>FloatingValue</code> </p> <code>lat2</code> <p>The latitude of the second point.</p> <p> TYPE: <code>FloatingValue</code> </p> <code>lon2</code> <p>The longitude of the second point.</p> <p> TYPE: <code>FloatingValue</code> </p> RETURNS DESCRIPTION <code>distance</code> <p>The distance between the two points, in kilometers.</p> <p> TYPE: <code>FloatingValue</code> </p>"},{"location":"reference/lib/geo/#addresses","title":"Addresses","text":""},{"location":"reference/lib/geo/#mismo.lib.geo.us_census_geocode","title":"mismo.lib.geo.us_census_geocode","text":"<pre><code>us_census_geocode(\n    t: Table,\n    format: str = \"census_{name}\",\n    *,\n    benchmark: str | None = None,\n    vintage: str | None = None,\n    chunk_size: int | None = None,\n    n_concurrent: int | None = None,\n) -&gt; Table\n</code></pre> <p>Geocode US physical addresses using the US Census Bureau's geocoding service.</p> <p>Uses the batch geocoding API from https://geocoding.geo.census.gov/geocoder. This only works for US physical addresses. PO Boxes are not supported. \"APT 123\", \"UNIT B\", etc are not included in the results, so you will need to extract those before geocoding.</p> <p>Before geocoding, this function normalizes the input addresses and deduplicates them, so if your input table has 1M rows, but only 100k unique addresses, it will only send those 100k addresses to the API.</p> <p>This took about 7 minutes to geocode 1M unique addresses in my tests.</p> PARAMETER DESCRIPTION <code>t</code> <p>A table of addresses to geocode. Must have the schema: - street: string, the street address. - city: string, the city name. - state: string, the state name. - zipcode: string, the ZIP code.</p> <p> TYPE: <code>Table</code> </p> <code>format</code> <p>The format to use for the output column names. See the Returns section.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'census_{name}'</code> </p> <code>benchmark</code> <p>The geocoding benchmark to use. Default is \"Public_AR_Current\".</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>vintage</code> <p>The geocoding vintage to use. Default is \"Current_Current\".</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>chunk_size</code> <p>The number of addresses to geocode in each request. Default is 5000. The maximum allowed by the API is 10_000. This number was tuned experimentally, you probably don't need to change ir.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>n_concurrent</code> <p>The number of concurrent requests to make. Default is 16. This number was tuned experimentally, you probably don't need to change ir.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>geocoded</code> <p>The input table, with the following additional columns: - is_match: bool, whether the address was successfully matched.   If False, all the other columns will be NULL. - match_type: string, the type of match. eg \"exact\", \"non_exact\" - street: string, the normalized street address - city: string, the normalized city name - state: string, the normalized 2 letter state code - zipcode: string, the 5 digit ZIP code - latitude: float64, the latitude of the matched address - longitude: float64, the longitude of the matched address Each of these columns is named according to the <code>format</code> parameter. For example, if <code>format</code> is \"census_{name}\", the columns will be named \"census_is_match\", \"census_match_type\", \"census_street\", etc. The order of the results is not guaranteed to match the input order.</p> <p> TYPE: <code>Table</code> </p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesDimension","title":"mismo.lib.geo.AddressesDimension","text":"<p>Preps, blocks, and compares based on array columns. <p>An address is a Struct of the type `struct&lt;     street1: string,     street2: string,  # eg \"Apt 3\"     city: string,     state: string,     postal_code: string,  # zipcode in the US     country: string,</p> <p><code>. This operates on columns of type</code>array`. In other words, it is useful for comparing eg people, who might have multiple addresses, and they are the same person if any of their addresses match."},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesDimension.prepare_for_blocking","title":"mismo.lib.geo.AddressesDimension.prepare_for_blocking","text":"<pre><code>prepare_for_blocking(t: Table) -&gt; Table\n</code></pre> <p>Prepares the table for blocking, adding normalized and tokenized columns.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesDimension.prepare_for_fast_linking","title":"mismo.lib.geo.AddressesDimension.prepare_for_fast_linking","text":"<pre><code>prepare_for_fast_linking(t: Table) -&gt; Table\n</code></pre> <p>Prepares the table for fast linking, adding a normalized column.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel","title":"mismo.lib.geo.AddressesMatchLevel","text":"<p>               Bases: <code>MatchLevel</code></p> <p>How closely two addresses match.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.ELSE","title":"mismo.lib.geo.AddressesMatchLevel.ELSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELSE = 6\n</code></pre> <p>None of the above.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.POSSIBLE_TYPO","title":"mismo.lib.geo.AddressesMatchLevel.POSSIBLE_TYPO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSSIBLE_TYPO = 1\n</code></pre> <p>If you consider typos, the addresses match.</p> <p>eg the levenstein distance is below a certain threshold.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.SAME_REGION","title":"mismo.lib.geo.AddressesMatchLevel.SAME_REGION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_REGION = 2\n</code></pre> <p>The postal code, or city and state, match.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.SAME_STATE","title":"mismo.lib.geo.AddressesMatchLevel.SAME_STATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SAME_STATE = 4\n</code></pre> <p>The states match.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.STREET1_AND_CITY_OR_POSTAL","title":"mismo.lib.geo.AddressesMatchLevel.STREET1_AND_CITY_OR_POSTAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STREET1_AND_CITY_OR_POSTAL = 0\n</code></pre> <p>The street1, city, and state match.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.AddressesMatchLevel.WITHIN_100KM","title":"mismo.lib.geo.AddressesMatchLevel.WITHIN_100KM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>WITHIN_100KM = 3\n</code></pre> <p>The addresses are within 100 km of each other.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.match_level","title":"mismo.lib.geo.match_level","text":"<pre><code>match_level(\n    left: StructValue, right: StructValue\n) -&gt; IntegerValue\n</code></pre> <p>Compare two address structs, and return the match level.</p>"},{"location":"reference/lib/geo/#mismo.lib.geo.postal_parse_address","title":"mismo.lib.geo.postal_parse_address","text":"<pre><code>postal_parse_address(\n    address_string: StringValue,\n) -&gt; StructValue\n</code></pre> <p>Parse individual fields from an address string.</p> <p>.. note:: To use this function, you need the optional <code>postal</code> library installed.</p> <p>This uses the optional <code>postal</code> library to extract individual fields from the string using the following mapping:</p> <ul> <li>house_number + road -&gt; street1</li> <li>unit -&gt; street2</li> <li>city -&gt; city</li> <li>state -&gt; state</li> <li>postcode -&gt; postal_code</li> <li>country -&gt; country</li> </ul> <p>Any additional fields parsed by postal will not be included.</p> PARAMETER DESCRIPTION <code>address_string</code> <p>The address as a single string</p> <p> TYPE: <code>StringValue</code> </p> RETURNS DESCRIPTION <code>address</code> <p>The parsed address as a Struct</p> <p> TYPE: <code>StructValue</code> </p>"},{"location":"reference/lib/geo/#mismo.lib.geo.postal_fingerprint_address","title":"mismo.lib.geo.postal_fingerprint_address","text":"<pre><code>postal_fingerprint_address(\n    address: StructValue,\n) -&gt; ArrayValue\n</code></pre> <p>Generate multiple hashes of an address string to be used for e.g. blocking.</p> <p>.. note:: To use this function, you need to have the optional <code>postal</code> library installed.</p> <p>This uses the near-dupe hashing functionality of <code>postal</code> to expand the root of each address component, ignoring tokens such as \"road\" or \"street\" in street names.</p> <p>For street names, whitespace is removed so that for example \"Sea Grape Ln\" and \"Seagrape Ln\" will both normalize to \"seagrape\".</p> <p>This returns a list of normalized tokens that are the minimum required information to represent the given address.</p> <p>Near-dupe hashes can be used as keys when blocking, to generate pairs of potential duplicates.</p> <p>Further details about the hashing function can be found here.</p> <p>Note that <code>postal.near_dupe.near_dupe_hashes</code> can optionally hash names and use latlon coordinates for geohashing, but this function only hashes addresses. Name and geo-hashing must be implemented elsewhere</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; address = ibis.struct(\n...     {\n...         \"street1\": \"123 Main Street\",\n...         \"street2\": \"\",\n...         \"city\": \"Springfield\",\n...         \"state\": \"IL\",\n...         \"postal_code\": \"62701\",\n...         \"country\": \"us\",\n...     }\n... )\n&gt;&gt;&gt; postal_fingerprint_address(address).execute()\n[\n    \"act|main street|123|springfield\",\n    \"act|main|123|springfield\",\n    \"apc|main street|123|62701\",\n    \"apc|main|123|62701\",\n]\n</code></pre> PARAMETER DESCRIPTION <code>address</code> <p>The address</p> <p> TYPE: <code>StructValue</code> </p> RETURNS DESCRIPTION <code>address_hashes</code> <p>Hashes of the address.</p> <p> TYPE: <code>ArrayValue</code> </p>"},{"location":"reference/lib/geo/#mismo.lib.geo.spacy_tag_address","title":"mismo.lib.geo.spacy_tag_address","text":"<pre><code>spacy_tag_address(\n    address_string: StringValue,\n) -&gt; ArrayValue\n</code></pre> <p>Tag each token in a US address string with its type, eg StreetName, StreetPreDirectional</p> <p>.. note:: To use this function, you need the optional <code>spacy-address</code> library installed from https://github.com/NickCrews/spacy-address</p> <p>This a trained Named Entity Recognition (NER) model in spaCy to tag tokens in an address string with the following labels:</p> <ul> <li>AddressNumber</li> <li>AddressNumberPrefix</li> <li>AddressNumberSuffix</li> <li>BuildingName</li> <li>CornerOf</li> <li>CountryName</li> <li>IntersectionSeparator</li> <li>LandmarkName</li> <li>NotAddress</li> <li>OccupancyIdentifier</li> <li>OccupancyType</li> <li>PlaceName</li> <li>Recipient</li> <li>StateName</li> <li>StreetName</li> <li>StreetNamePostDirectional</li> <li>StreetNamePostModifier</li> <li>StreetNamePostType</li> <li>StreetNamePreDirectional</li> <li>StreetNamePreModifier</li> <li>StreetNamePreType</li> <li>SubaddressIdentifier</li> <li>SubaddressType</li> <li>USPSBoxGroupID</li> <li>USPSBoxGroupType</li> <li>USPSBoxID</li> <li>USPSBoxType</li> <li>ZipCode</li> <li>ZipPlus4</li> </ul> PARAMETER DESCRIPTION <code>address_string</code> <p>The address as a single string</p> <p> TYPE: <code>StringValue</code> </p> RETURNS DESCRIPTION <code>taggings</code> <p>An <code>array&lt;struct&lt;token: string, label: string&gt;&gt;</code> with the tagged tokens</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from mismo.lib.geo import spacy_tag_address\n&gt;&gt;&gt; import ibis\n</code></pre> <p>Note that - \"St\" isn't confused as an abbreviation for Street, - \"Stre\" is correctly tagged as typo for \"Street\" - \"Oklahoma\" in \"Oklahoma City\" is correctly tagged as a PlaceName - \"Oklhoma\" is correctly tagged as a typo for \"Oklahoma\"</p> <pre><code>&gt;&gt;&gt; spacy_tag_address(\n...     ibis.literal(\"456 E St Jude Stre, Oklahoma City, Oklhoma 73102-1234\")\n... ).execute()\n[{'token': '456', 'label': 'AddressNumber'},\n{'token': 'E', 'label': 'StreetNamePreDirectional'},\n{'token': 'St Jude', 'label': 'StreetName'},\n{'token': 'Stre', 'label': 'StreetNamePostType'},\n{'token': 'Oklahoma City', 'label': 'PlaceName'},\n{'token': 'Oklhoma', 'label': 'StateName'},\n{'token': '73102-1234', 'label': 'ZipCode'}]\n</code></pre>"},{"location":"reference/lib/name/","title":"Human Names API","text":"<p>This contains utilities, blockers, and comparers relevant to human names</p>"},{"location":"reference/lib/name/#mismo.lib.name.normalize_name","title":"mismo.lib.name.normalize_name","text":"<pre><code>normalize_name(name: StructValue) -&gt; StructValue\n</code></pre> <p>Convert to uppercase, normalize whitespace, and remove non-alphanumeric.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name to normalize.</p> <p> TYPE: <code>StructValue</code> </p> RETURNS DESCRIPTION <code>name_normed</code> <p>The normalized name.</p> <p> TYPE: <code>StructValue</code> </p>"},{"location":"reference/lib/name/#mismo.lib.name.are_aliases","title":"mismo.lib.name.are_aliases","text":"<pre><code>are_aliases(\n    name1: StringValue, name2: StringValue\n) -&gt; BooleanValue\n</code></pre><pre><code>are_aliases(name1: str, name2: str) -&gt; bool\n</code></pre> <pre><code>are_aliases(name1, name2)\n</code></pre> <p>Determine if two names are nickname interchangeable.</p> <p>This is case-insensitive, and whitespace is stripped from both ends. The same name returns True.</p>"},{"location":"reference/lib/name/#mismo.lib.name.is_nickname_for","title":"mismo.lib.name.is_nickname_for","text":"<pre><code>is_nickname_for(\n    nickname: StringValue, canonical: StringValue\n) -&gt; BooleanValue\n</code></pre><pre><code>is_nickname_for(nickname: str, canonical: str) -&gt; bool\n</code></pre> <pre><code>is_nickname_for(nickname, canonical)\n</code></pre> <p>Determine if a name is a nickname for another name.</p> <p>This is case-insensitive, and whitespace is stripped from both ends. The same name returns True.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel","title":"mismo.lib.name.NameMatchLevel","text":"<p>               Bases: <code>MatchLevel</code></p> <p>How closely two names match.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.ELSE","title":"mismo.lib.name.NameMatchLevel.ELSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELSE = 6\n</code></pre> <p>None of the above.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.EXACT","title":"mismo.lib.name.NameMatchLevel.EXACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXACT = 1\n</code></pre> <p>The names are exactly the same.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.GIVEN_SURNAME","title":"mismo.lib.name.NameMatchLevel.GIVEN_SURNAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>GIVEN_SURNAME = 2\n</code></pre> <p>The given and surnames both match.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.INITIALS","title":"mismo.lib.name.NameMatchLevel.INITIALS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INITIALS = 4\n</code></pre> <p>The first letter of the given name matches, and the surnames match.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.NICKNAMES","title":"mismo.lib.name.NameMatchLevel.NICKNAMES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NICKNAMES = 3\n</code></pre> <p>The given names match with nicknames, and the surnames match.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.NULL","title":"mismo.lib.name.NameMatchLevel.NULL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NULL = 0\n</code></pre> <p>At least one given or surname is NULL from either side.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameMatchLevel.TYPO","title":"mismo.lib.name.NameMatchLevel.TYPO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TYPO = 5\n</code></pre> <p>The given names are the same (forgiving typos), and the surnames match.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameComparer","title":"mismo.lib.name.NameComparer","text":"<p>Compare names. Assumes the names have already been normalized/featurized.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameComparer.Levels","title":"mismo.lib.name.NameComparer.Levels  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Levels = NameMatchLevel\n</code></pre> <p>The levels of name comparison.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameComparer.__call__","title":"mismo.lib.name.NameComparer.__call__","text":"<pre><code>__call__(\n    table: Table | None = None,\n    *,\n    left: StructValue | None = None,\n    right: StructValue | None = None,\n) -&gt; IntegerValue\n</code></pre> <p>Compare two names.</p> PARAMETER DESCRIPTION <code>left</code> <p>The left name.</p> <p> TYPE: <code>StructValue | None</code> DEFAULT: <code>None</code> </p> <code>right</code> <p>The right name.</p> <p> TYPE: <code>StructValue | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>t</code> <p>The comparison result.</p> <p> TYPE: <code>IntegerValue</code> </p>"},{"location":"reference/lib/name/#mismo.lib.name.NameDimension","title":"mismo.lib.name.NameDimension","text":"<p>Prepares, blocks, and compares based on a human name.</p> <p>A name is a Struct of the type `struct&lt;     prefix: string,     given: string,     middle: string,     surname: string,     suffix: string,     nickname: string,</p> <p>`.</p>"},{"location":"reference/lib/name/#mismo.lib.name.NameDimension.compare","title":"mismo.lib.name.NameDimension.compare","text":"<pre><code>compare(t: Table) -&gt; Table\n</code></pre> <p>Compare the left and right names.</p> PARAMETER DESCRIPTION <code>t</code> <p>The table to compare.</p> <p> TYPE: <code>Table</code> </p> RETURNS DESCRIPTION <code>t</code> <p>The compared table.</p> <p> TYPE: <code>Table</code> </p>"},{"location":"reference/lib/name/#mismo.lib.name.NameDimension.prepare_for_fast_linking","title":"mismo.lib.name.NameDimension.prepare_for_fast_linking","text":"<pre><code>prepare_for_fast_linking(t: Table) -&gt; Table\n</code></pre> <p>Add columns with the normalized name.</p> PARAMETER DESCRIPTION <code>t</code> <p>The table to prep.</p> <p> TYPE: <code>Table</code> </p> RETURNS DESCRIPTION <code>t</code> <p>The prepped table.</p>"},{"location":"reference/lib/phone/","title":"Phones API","text":"<p>This contains utilities, blockers, and comparers relevant to phone numbers</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.clean_phone_number","title":"mismo.lib.phone.clean_phone_number","text":"<pre><code>clean_phone_number(\n    phones: Table, *, default_area_code: str | None = None\n) -&gt; Table\n</code></pre><pre><code>clean_phone_number(\n    phones: ArrayValue,\n    *,\n    default_area_code: str | None = None,\n) -&gt; ArrayValue\n</code></pre><pre><code>clean_phone_number(\n    phones: StringValue,\n    *,\n    default_area_code: str | None = None,\n) -&gt; StringValue\n</code></pre> <pre><code>clean_phone_number(numbers, *, default_area_code=None)\n</code></pre> <p>Extracts any 10-digit number from a string.</p> <p>Drops leading 1 country code if present.</p> <p>Parsing failures are returned as NULL.</p> <p>Empty strings are returned as NULL.</p> <p>If you supply a default_area_code, it will be prepended to 7-digit numbers.</p> <p>If a number looks bogus, ie it contains \"0000\", \"9999\", or \"12345\", it is set to NULL.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.match_level","title":"mismo.lib.phone.match_level","text":"<pre><code>match_level(\n    p1: StringValue,\n    p2: StringValue,\n    *,\n    native_representation: Literal[\n        \"integer\", \"string\"\n    ] = \"integer\",\n) -&gt; PhoneMatchLevel\n</code></pre> <p>Match level of two phone numbers.</p> <p>Assumes the phone numbers have already been cleaned and normalized.</p> PARAMETER DESCRIPTION <code>p1</code> <p>The first phone number.</p> <p> TYPE: <code>StringValue</code> </p> <code>p2</code> <p>The second phone number.</p> <p> TYPE: <code>StringValue</code> </p> RETURNS DESCRIPTION <code>level</code> <p>The match level.</p> <p> TYPE: <code>PhoneMatchLevel</code> </p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhoneMatchLevel","title":"mismo.lib.phone.PhoneMatchLevel","text":"<p>               Bases: <code>MatchLevel</code></p> <p>How closely two phone numbers match.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhoneMatchLevel.ELSE","title":"mismo.lib.phone.PhoneMatchLevel.ELSE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ELSE = 2\n</code></pre> <p>None of the above.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhoneMatchLevel.EXACT","title":"mismo.lib.phone.PhoneMatchLevel.EXACT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXACT = 0\n</code></pre> <p>The numbers are exactly the same.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhoneMatchLevel.NEAR","title":"mismo.lib.phone.PhoneMatchLevel.NEAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NEAR = 1\n</code></pre> <p>The numbers have a small edit distance.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhonesDimension","title":"mismo.lib.phone.PhonesDimension","text":"<p>Prepares, blocks, and compares sets of phone numbers.</p> <p>This is useful if each record contains a collection of phone numbers. Two records are probably the same if they have a lot of phone numbers in common.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhonesDimension.__init__","title":"mismo.lib.phone.PhonesDimension.__init__","text":"<pre><code>__init__(\n    column: str,\n    *,\n    column_cleaned: str = \"{column}_cleaned\",\n    column_compared: str = \"{column}_compared\",\n)\n</code></pre> <p>Initialize the dimension.</p> PARAMETER DESCRIPTION <code>column</code> <p>The name of the column that holds a array of phone numbers. <p> TYPE: <code>str</code> </p> <code>column_cleaned</code> <p>The name of the column that will be filled with the parsed phone numbers.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{column}_cleaned'</code> </p> <code>column_compared</code> <p>The name of the column that will be filled with the comparison results.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'{column}_compared'</code> </p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhonesDimension.compare","title":"mismo.lib.phone.PhonesDimension.compare","text":"<pre><code>compare(t: Table) -&gt; Table\n</code></pre> <p>Add a column with the best match between all pairs of phone numbers.</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhonesDimension.prepare_for_blocking","title":"mismo.lib.phone.PhonesDimension.prepare_for_blocking","text":"<pre><code>prepare_for_blocking(t: Table) -&gt; Table\n</code></pre> <p>noop</p>"},{"location":"reference/lib/phone/#mismo.lib.phone.PhonesDimension.prepare_for_fast_linking","title":"mismo.lib.phone.PhonesDimension.prepare_for_fast_linking","text":"<pre><code>prepare_for_fast_linking(t: Table) -&gt; Table\n</code></pre> <p>Add a column with the parsed and normalized phone numbers.</p>"}]}